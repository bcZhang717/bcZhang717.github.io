<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>分布式锁介绍及基本原理 | 欢迎来到爱谦 717 的博客</title><meta name="author" content="bcZhang"><meta name="copyright" content="bcZhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这篇文章详细介绍了分布式锁的概念、原理和实现方式。文章首先解释了在多线程环境中为什么需要锁机制来保护共享资源，以及在分布式系统中本地锁的局限性，从而引出分布式锁的必要性。 接着，文章阐述了分布式锁设计需要满足的几个关键条件，包括互斥性、高可用性、可重入性、高性能和对称性，并介绍了三种主流的分布式锁实现方案：基于MySQL数据库、基于Redis&#x2F;Etcd存储系统和基于ZooKeeper协调服务。 文">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式锁介绍及基本原理">
<meta property="og:url" content="https://bczhang717.github.io/2025/08/23/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="欢迎来到爱谦 717 的博客">
<meta property="og:description" content="这篇文章详细介绍了分布式锁的概念、原理和实现方式。文章首先解释了在多线程环境中为什么需要锁机制来保护共享资源，以及在分布式系统中本地锁的局限性，从而引出分布式锁的必要性。 接着，文章阐述了分布式锁设计需要满足的几个关键条件，包括互斥性、高可用性、可重入性、高性能和对称性，并介绍了三种主流的分布式锁实现方案：基于MySQL数据库、基于Redis&#x2F;Etcd存储系统和基于ZooKeeper协调服务。 文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bczhang717.github.io/img/default3.jpg">
<meta property="article:published_time" content="2025-08-22T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-24T03:54:09.420Z">
<meta property="article:author" content="bcZhang">
<meta property="article:tag" content="分布式锁">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="Redisson">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bczhang717.github.io/img/default3.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "分布式锁介绍及基本原理",
  "url": "https://bczhang717.github.io/2025/08/23/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/",
  "image": "https://bczhang717.github.io/img/default3.jpg",
  "datePublished": "2025-08-22T16:00:00.000Z",
  "dateModified": "2025-08-24T03:54:09.420Z",
  "author": [
    {
      "@type": "Person",
      "name": "bcZhang",
      "url": "https://bczhang717.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/icon.webp"><link rel="canonical" href="https://bczhang717.github.io/2025/08/23/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":2510,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '分布式锁介绍及基本原理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4748730_3aikgrelxhp.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/error-page.png'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default3.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">欢迎来到爱谦 717 的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">分布式锁介绍及基本原理</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">分布式锁介绍及基本原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2025-08-22T16:00:00.000Z" title="发表于 2025-08-23 00:00:00">2025-08-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="锁与分布式锁"><a href="#锁与分布式锁" class="headerlink" title="锁与分布式锁"></a>锁与分布式锁</h1><p>在多线程环境中，如果多个线程同时访问共享资源 (例如商品库存、外卖订单)，会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。</p>
<p>举个例子，假设现在有 100 个用户参与某个限时秒杀活动，每位用户限购 1 件商品，且商品的数量只有 3 个。如果不对共享资源进行互斥访问，就可能出现以下情况：</p>
<ul>
<li>线程 1、2、3 等多个线程同时进入抢购方法，每一个线程对应一个用户。</li>
<li>线程 1 查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。</li>
<li>线程 2 也执行查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。</li>
<li>线程 1 继续执行，将库存数量减少 1 个，然后返回成功。</li>
<li>线程 2 继续执行，将库存数量减少 1 个，然后返回成功。</li>
<li>此时就发生了超卖问题，导致商品被多卖了一份。</li>
</ul>
<h2 id="锁的出现"><a href="#锁的出现" class="headerlink" title="锁的出现"></a>锁的出现</h2><p>为了保证共享资源被安全地访问，我们需要使用互斥操作对共享资源进行保护，<strong>即同一时刻只允许一个线程访问共享资源</strong>，其他线程需要等待当前线程释放后才能访问。这样可以避免数据竞争和脏数据问题，保证程序的正确性和稳定性。</p>
<p>在计算机领域，锁可以理解为针对某项资源使用权限的管理，它通常用来 <strong>控制共享资源</strong>，比如一个进程内有多个线程竞争一个数据的使用权限，解决方式之一就是加锁，更确切的说则是 “悲观锁”。</p>
<p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题 (比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会被阻塞，直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p>
<p>对于单体应用来说，在 Java 中，我们通常会使用 <code>ReentrantLock</code> 类、<code>synchronized</code> 关键字这类 JDK 本身就拥有的方式来控制一个 JVM 进程内的多个线程对共享资源的访问。<br><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250822182730857.png" alt="image-20250822182442644" /><br>从图中可以看出，这些线程访问共享资源是互斥的，<strong>同一时刻只有一个线程可以获取到本地锁访问共享资源</strong>。</p>
<h2 id="分布式锁的出现"><a href="#分布式锁的出现" class="headerlink" title="分布式锁的出现"></a>分布式锁的出现</h2><p>分布式系统下，不同的服务&#x2F;客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，<strong>分布式锁</strong> 就诞生了。</p>
<p>举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于 <strong>不同的 JVM 进程</strong> 中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。<br><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250822183716898.png" alt="image-20250822183716824" /><br>从图中可以看出，这些独立的进程中的线程访问共享资源是互斥的，<strong>同一时刻只有一个线程可以获取到分布式锁访问共享资源</strong>。</p>
<h1 id="分布式锁设计注意事项"><a href="#分布式锁设计注意事项" class="headerlink" title="分布式锁设计注意事项"></a>分布式锁设计注意事项</h1><h2 id="设计分布式锁需要具备哪些条件？"><a href="#设计分布式锁需要具备哪些条件？" class="headerlink" title="设计分布式锁需要具备哪些条件？"></a>设计分布式锁需要具备哪些条件？</h2><p>1、<strong>互斥</strong>：同一时刻保证只有一个线程能够获得锁，去访问共享资源。</p>
<p>2、<strong>高可用</strong>：要保证即使出现异常的情况也要对锁进行释放，确保不会影响其他线程对共享资源的访问。</p>
<p>3、<strong>可重入</strong>：一个节点获取了锁之后，还可以再次获取到锁，并且不止一次。</p>
<p>4、<strong>高性能</strong>：获取和释放锁的操作应该快速完成，并且尽量不要对整个系统的性能造成太大的影响。</p>
<p>5、<strong>对称性</strong>：确保加锁和解锁的是同一个线程，避免出现锁的 “误释放”。</p>
<h2 id="分布式锁有哪些实现方案？"><a href="#分布式锁有哪些实现方案？" class="headerlink" title="分布式锁有哪些实现方案？"></a>分布式锁有哪些实现方案？</h2><p>主流的分布式锁实现方案主要有 3 种：</p>
<ul>
<li>基于关系型数据库 MySQL 实现分布式锁</li>
<li>基于分布式存储系统 Redis 或 Etcd 实现分布式锁</li>
<li>基于分布式协调服务 ZooKeeper 实现分布式锁</li>
</ul>
<p>鉴于种种原因，实际在生产过程中使用 Redis 或 ZooKeeper 实现分布式锁居多。</p>
<h1 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h1><h2 id="基于-Redis-循序渐进实现分布式锁"><a href="#基于-Redis-循序渐进实现分布式锁" class="headerlink" title="基于 Redis 循序渐进实现分布式锁"></a>基于 Redis 循序渐进实现分布式锁</h2><h3 id="最简单的分布式锁"><a href="#最简单的分布式锁" class="headerlink" title="最简单的分布式锁"></a>最简单的分布式锁</h3><p>要实现一个分布式锁，得满足锁的基本特性：即一个线程拿到锁，另一个线程就拿不到，就不能往下走，这就是锁的互斥性。</p>
<p>在 Redis 当中，提供了一个 <code>SETNX</code> 的命令来帮助我们实现一个简单的分布式锁。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure>

<p>Redis 官方对于该命令的解释是：<code>Set the string value of a key only when the key doesn&#39;t exist</code> 只有当 key 不存在的时候，才会设置 key 的值 (加锁)。这样就可以帮助我们天然的实现分布式场景下的互斥性。</p>
<p>但是为了保证对称性，在解锁的时候我们则需要先判断这个锁是否是当前线程加的锁，从而避免释放掉别人的锁。此时就包括两个步骤：判断、释放锁。但是为了避免多线程环境下的并发安全问题，我们则需要使用 Lua 脚本来保证这两条命令的原子性。</p>
<p>释放锁的 Lua 脚本示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁时, 先比较锁对应的 value 值是否相等, 避免锁的误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>至于为什么不把 <code>SETNX</code> 命令放到 Lua 脚本当中，这是因为 Redis 执行操作命令是单线程执行的，天然就是原子性操作。</p>
<p>这是实现分布式锁的最简易版本，会存在大量的问题。比如：<strong>如果一个线程拿到锁之后就挂了，此时就无法释放锁了，该怎么办？</strong></p>
<h3 id="带有过期时间的分布式锁"><a href="#带有过期时间的分布式锁" class="headerlink" title="带有过期时间的分布式锁"></a>带有过期时间的分布式锁</h3><p>为了解决上述出现的问题，我们就需要给这个锁设置一个过期时间。Redis 当中也存在了设置过期时间对应的 <code>SET</code> 命令。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]</span><br></pre></td></tr></table></figure>

<p>具体解释每一个命令如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> SET key value: 设置 key 与 value</span><br><span class="line"><span class="bullet">2.</span> []: 代表可选操作</span><br><span class="line"><span class="bullet">3.</span> NX|XX: 二选一属性</span><br><span class="line"><span class="bullet">   -</span> NX(Not Exists): 只有当 key 不存在的时候才会设置 key 的值, 相当于上面的 <span class="code">`SETNX`</span> 命令</span><br><span class="line"><span class="bullet">   -</span> XX(Exists): 只有当 key 存在的时候才会设置 key 的值, 不存在则忽略该操作</span><br><span class="line"><span class="bullet">4.</span> GET: 执行 <span class="code">`SET`</span> 操作的同时返回原来的旧值, 如果 key 不存在, 返回 nil</span><br><span class="line"><span class="bullet">   -</span> 示例: </span><br><span class="line"><span class="bullet">       1.</span> 执行: SET name &quot;Alice&quot;</span><br><span class="line"><span class="bullet">       2.</span> 返回: OK</span><br><span class="line"><span class="bullet">       3.</span> 执行: SET name &quot;Bob&quot; GET</span><br><span class="line"><span class="bullet">       4.</span> 返回: &quot;Alice&quot;</span><br><span class="line"><span class="bullet">5.</span> 过期时间参数, 只能选一个</span><br><span class="line"><span class="bullet">   -</span> EX seconds: 设置过期时间为 xx 秒(整数)</span><br><span class="line"><span class="bullet">   -</span> PX milliseconds: 设置过期时间为 xx 毫秒(整数)</span><br><span class="line"><span class="bullet">   -</span> EXAT unix-time-seconds: 设置过期的 Unix 时间戳(秒级), 到指定时间后过期</span><br><span class="line"><span class="bullet">   -</span> PXAT unix-time-milliseconds: 设置过期的 Unix 时间戳(毫秒级), 到指定时间后过期</span><br><span class="line"><span class="bullet">   -</span> KEEPTTL: 保留 key 原有的过期时间(如果 key 已存在且有过期时间, 则不改变其过期时间; 如果 key 不存在, 则设置为永久)</span><br></pre></td></tr></table></figure>

<p>针对于 <code>SET</code> 命令实现可过期的分布式锁，具体的命令示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数的顺序不会影响命令</span></span><br><span class="line">SET lockKey uniqueValue EX 3 NX 或 SET lockKey uniqueValue NX EX 3 <span class="comment"># 3s 后过期</span></span><br></pre></td></tr></table></figure>

<p>这种方式实现的分布式锁还是会存在问题：<strong>假设线程拿到锁后任务还没有执行完成，锁就已经过期了，这个时候该怎么办？</strong></p>
<h3 id="锁的优雅续期"><a href="#锁的优雅续期" class="headerlink" title="锁的优雅续期"></a>锁的优雅续期</h3><p>此时我们应该想：如果能够自动判断锁的过期时间，在业务还没执行完的时候进行锁的自动续期，这该多是一件美事！！！</p>
<p>针对于这种情况，Java 已经有了现成的解决方案：<strong>Redisson</strong>。Redisson 是一个基于 Redis 的 Java 高级客户端，底层基于 Netty 实现。Redisson 提供了如分布式锁、分布式限流、分布式集合等高级特性。</p>
<p>Redisson 中的分布式锁自带自动续期机制，使用起来非常简单。其提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。<br><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250822195810641.png" alt="image-20250822195810515" /><br>关于 Watch Dog 看门狗机制，这里不做过多阐述，后续会单独写一篇文章进行详细说明。</p>
<p>通过续期方式实现的分布式锁还是会存在一定的问题：<strong>假设线程拿到锁在执行业务方法的时候挂了，这时候  Watch Dog 就会不断地给锁进行续期，该怎么解决？有些场景还需要使用到可重入的分布式锁，又该怎么解决？</strong></p>
<h3 id="可重入的分布式锁"><a href="#可重入的分布式锁" class="headerlink" title="可重入的分布式锁"></a>可重入的分布式锁</h3><p>针对于上述第一个问题，我们可以这样操作：</p>
<ul>
<li>把看门狗线程设置为守护线程，守护线程的生命周期依赖于其他线程，一旦拿到锁的线程在执行业务的时候挂了，那么看门狗作为守护线程也是会停止的。</li>
<li>我们也需要给看门狗设置一个时间 (默认30s 续期一次)，避免无限续期。</li>
</ul>
<p>下面来讨论可重入分布式锁的实现。</p>
<p>可重入锁指的是 <strong>在一个线程中可以多次获取同一把锁</strong>。比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程就需要多次来获取同一个锁，这就是可重入锁。</p>
<p>Java 中的 <code>synchronized</code> 和 <code>ReentrantLock</code> 都属于可重入锁。</p>
<p>那我们该怎么实现一个可重入锁呢？在解答这个问题之前，需要先看看 <code>synchronized</code> 和 <code>ReentrantLock</code> 是怎么实现可重入的。</p>
<p>synchronized 给每个对象都关联了一个锁监视器，监视器中有个字段是锁计数器。锁重入一次，计数器加一次，锁释放一次，计数器减一次，当计数器为 0 的时候，就是锁释放完毕的时候。</p>
<p>ReentrantLock 基于 AQS 进行实现。AQS 中存在一个 state 字段，state 字段就充当了锁计数器，锁重入一次，state 加一次，锁释放一次，state 减一次，当 state 为 0 的时候，就是锁释放完毕的时候。</p>
<p>那么对于可重入的分布式锁，实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 <strong>Redisson</strong> ，其内置了多种类型的锁。比如可重入锁 (Reentrant Lock)、自旋锁 (Spin Lock)、公平锁 (Fair Lock)、多重锁 (MultiLock)、 红锁 (RedLock)、 读写锁 (ReadWriteLock)。</p>
<p>而如果让我们自行实现可重入的分布式锁，则也需要根据锁计数器来实现，主要的实现方案有以下两种。</p>
<h4 id="第一种方案"><a href="#第一种方案" class="headerlink" title="第一种方案"></a>第一种方案</h4><p>使用 Redis 的哈希结构，以要锁的东西为 key，以当前的线程 Id 为 field，以重入次数为 value，这个 value 充当的角色就是锁计数器。</p>
<p>当然，这种方案也是 Redisson 可重入锁的实现方案，使用的是 <code>HSETNX</code> 命令。</p>
<p>但是由于集群环境下可能会出现线程 Id 重复的现象，我们最好是使用当前的线程 Id 再拼接一个 UUID 来保证唯一性。</p>
<h4 id="第二种方案"><a href="#第二种方案" class="headerlink" title="第二种方案"></a>第二种方案</h4><p>不使用 Redisson 提供好的可重入分布式锁，还是使用 Redis 中的 String 结构的 <code>SET NX EX</code> 命令来实现分布式锁，但是在服务内部维护一个 <code>ConcurrentHashMap</code> ，以 map 的 value 作为锁计数器，来实现锁的可重入性。</p>
<h3 id="Redisson-中的发布订阅"><a href="#Redisson-中的发布订阅" class="headerlink" title="Redisson 中的发布订阅"></a>Redisson 中的发布订阅</h3><p><strong>如果一个线程抢到锁去执行业务去了，那么其他没抢到锁的线程就直接返回失败吗？</strong></p>
<p>当然不是。没抢到锁的线程不会直接返回失败信息，可以进行重试机制。分布式锁也可以通过不断自旋来尝试重新抢锁，但是 Redisson 底层不是这么实现的。</p>
<p>Redisson 基于 Redis 的发布订阅机制，让没有抢到锁的线程进行订阅，然后阻塞等待。</p>
<p>抢到锁的线程执行完任务后会发布一条消息来通知订阅的所有线程，唤醒它们进行重新抢锁。</p>
<p>没抢到锁的线程继续订阅，抢到锁的线程继续执行业务，执行完业务后继续发布消息，如此循环往复。不过需要注意的是要添加一个超时时间来进行控制，避免抢不到锁的线程无限等待下去。</p>
<h3 id="Redis-集群环境下的锁丢失问题"><a href="#Redis-集群环境下的锁丢失问题" class="headerlink" title="Redis 集群环境下的锁丢失问题"></a>Redis 集群环境下的锁丢失问题</h3><p>如果 Redis 是一主多从的集群模式，当执行分布式锁的 Redis 命令写入到主节点后，主节点正在或是即将同步数据给从节点的某一刻，Redis 的主节点突然宕机了，那么就会触发 Redis 的重新选主操作，选择某一个从节点转化为主节点。</p>
<p>但是新的主节点是没有分布式锁的数据的，那么其他线程还是能够加锁成功的，由于开始的主节点宕机没有及时同步数据到从节点，这就造成了第一次加的锁造成了丢失，这又该如何应对？</p>
<h4 id="Redisson-的联锁-MultiLock"><a href="#Redisson-的联锁-MultiLock" class="headerlink" title="Redisson 的联锁 (MultiLock)"></a>Redisson 的联锁 (MultiLock)</h4><p>针对于以上锁丢失问题，Redisson 提供了 <strong>联锁</strong> 机制来解决。联锁要求 Redis 部署多主多从的集群环境。</p>
<p>每次加锁都必须给所有主节点都加上锁才算加锁成功。</p>
<p>这样即便某个主节点还没来得及同步数据就宕机，那么其他几个主节点也是有锁的数据的，新线程再想加锁, 由于无法给所有主节点都加锁，还是会加锁失败的。这样就解决了一主多从模式下锁丢失的问题。</p>
<p><strong>但是真的完美了吗？</strong></p>
<p><strong>在给所有主节点加锁的过程中，如果某个主节点网络延迟很大，加锁很慢，或者说某个主节点宕机了，一直加锁失败，由于联锁的机制，那就会导致整体加锁失败。</strong></p>
<p><strong>此时我们又该如何应对？</strong></p>
<h4 id="Redisson-的红锁-RedLock"><a href="#Redisson-的红锁-RedLock" class="headerlink" title="Redisson 的红锁 (RedLock)"></a>Redisson 的红锁 (RedLock)</h4><p>此时就需要请出 Redisson 的又一个锁机制了：<strong>RedLock 红锁</strong>。RedLock 也要求 Redis 部署多主多从的集群环境，但是加锁的时候不需要全部的主节点都加锁成功，而是只需要 <strong>半数以上的主节点加锁成功即可</strong> 。</p>
<p>当某个线程加锁半数以上节点都成功了，那其他线程就不可能再做到半数以上加锁成功，这就满足了互斥性。</p>
<p>同时 RedLock 对加锁时间也有很严格的要求，如果某个节点一定时间内加不上锁就不等了，反正只要半数以上成功就行，放弃一两个比较慢的主节点是无所谓的。</p>
<p><strong>但是但是但是，到这里就万无一失了吗？</strong></p>
<p>显然并不是，RedLock 还存在一些其他的问题：</p>
<ul>
<li>RedLock 对时间要求很严格，但是不同节点的系统时钟也可能不一致，从而导致问题。</li>
<li>Java 的 GC 过程中是会暂停线程的，从而导致看门狗线程无法对锁进行续期，也可能导致锁的超时过期。</li>
<li>RedLock 自身也存在一定的问题，且需要搭建复杂的多主多从集群模式，维护起来非常困难，还要保证多个节点之间的数据一致性，因此 RedLock 的使用场景并不广泛。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上所述，实现分布式锁的最佳实践有两种方式：</p>
<ul>
<li>基于 Redis 的 <code>SET NX EX</code> 实现简单的不可重入的分布式锁。</li>
<li>直接使用 Redisson 提供好的分布式锁机制。</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">分布式锁</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/Redisson/">Redisson</a></div><div class="post-share"><div class="social-share" data-image="/img/default3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/QQ.png" target="_blank"><img class="post-qr-code-img" src="/img/QQ.png" alt="QQ"/></a><div class="post-qr-code-desc">QQ</div></li><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/08/23/hello-world/" title="Hello World"><img class="cover" src="/img/default2.webp" onerror="onerror=null;src='/img/error-page.png'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ ...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC82MDg3OS8zNzM0OQ=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/error-page.png'" alt="avatar"/></div><div class="author-info-name">bcZhang</div><div class="author-info-description">永远相信美好的事情即将发生</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/bcZhang"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/bcZhang" target="_blank" title="GitHub"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/18240724834@163.com" target="_blank" title="邮箱"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/img/chat.png" target="_blank" title="微信"><i class="fab fa-weixin" style="color: #63E6BE;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到爱谦 717 的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.</span> <span class="toc-text">锁与分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="toc-number">1.1.</span> <span class="toc-text">锁的出现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">分布式锁的出现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AE%BE%E8%AE%A1%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.</span> <span class="toc-text">分布式锁设计注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%9C%80%E8%A6%81%E5%85%B7%E5%A4%87%E5%93%AA%E4%BA%9B%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">设计分布式锁需要具备哪些条件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">分布式锁有哪些实现方案？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">分布式锁实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-Redis-%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.1.</span> <span class="toc-text">基于 Redis 循序渐进实现分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.1.1.</span> <span class="toc-text">最简单的分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.1.2.</span> <span class="toc-text">带有过期时间的分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E4%BC%98%E9%9B%85%E7%BB%AD%E6%9C%9F"><span class="toc-number">3.1.3.</span> <span class="toc-text">锁的优雅续期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.1.4.</span> <span class="toc-text">可重入的分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">第一种方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">第二种方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson-%E4%B8%AD%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">3.1.5.</span> <span class="toc-text">Redisson 中的发布订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E9%94%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.6.</span> <span class="toc-text">Redis 集群环境下的锁丢失问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson-%E7%9A%84%E8%81%94%E9%94%81-MultiLock"><span class="toc-number">3.1.6.1.</span> <span class="toc-text">Redisson 的联锁 (MultiLock)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson-%E7%9A%84%E7%BA%A2%E9%94%81-RedLock"><span class="toc-number">3.1.6.2.</span> <span class="toc-text">Redisson 的红锁 (RedLock)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.1.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/23/hello-world/" title="Hello World"><img src="/img/default2.webp" onerror="this.onerror=null;this.src='/img/error-page.png'" alt="Hello World"/></a><div class="content"><a class="title" href="/2025/08/23/hello-world/" title="Hello World">Hello World</a><time datetime="2025-08-23T02:02:19.968Z" title="发表于 2025-08-23 10:02:19">2025-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/23/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="分布式锁介绍及基本原理"><img src="/img/default3.jpg" onerror="this.onerror=null;this.src='/img/error-page.png'" alt="分布式锁介绍及基本原理"/></a><div class="content"><a class="title" href="/2025/08/23/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="分布式锁介绍及基本原理">分布式锁介绍及基本原理</a><time datetime="2025-08-22T16:00:00.000Z" title="发表于 2025-08-23 00:00:00">2025-08-23</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By bcZhang</span></div><div class="footer_custom_text">永远相信的美好的事情即将发生🥰</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'

  const loadLivere = (el, path) => {
    window.livereOptions = {
      refer: path || location.pathname
    }

    if (isShuoshuo) {
      window.shuoshuoComment.destroyLivere = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if (isShuoshuo) {
    'Livere' === 'Livere'
      ? window.shuoshuoComment = { loadComment: loadLivere }
      : window.loadOtherComment = loadLivere
    return
  }

  if ('Livere' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><div class="aplayer no-destroy" data-id="2629584905" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-order="random"> </div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:description\"]","link[rel=\"canonical\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      true
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="请输入关键词" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>