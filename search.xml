<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Butterfly 引入卡片链接</title>
      <link href="/2025/08/28/Butterfly/Butterfly%20%E5%BC%95%E5%85%A5%E5%8D%A1%E7%89%87%E9%93%BE%E6%8E%A5/"/>
      <url>/2025/08/28/Butterfly/Butterfly%20%E5%BC%95%E5%85%A5%E5%8D%A1%E7%89%87%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><a href="https://gitee.com" target="_blank" title="Gitee" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src=" https://gitee.com/favicon.ico" class="no-lightbox"></div><div class="link_content"><div class="link_title">Gitee</div><div class="link_desc">这是 Gitee</div></div></a><h1 id="实现卡片链接"><a href="#实现卡片链接" class="headerlink" title="实现卡片链接"></a>实现卡片链接</h1><h2 id="引入-js-文件"><a href="#引入-js-文件" class="headerlink" title="引入 js 文件"></a>引入 js 文件</h2><p>找到 <code>node_modules/hexo-theme-butterfly/scripts/tag</code> 文件夹，在该目录下创建 <code>link.js</code> 文件。</p><p>其内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * link</span></span><br><span class="line"><span class="comment"> * &#123;% link url,title,favicon,desc %&#125;</span></span><br><span class="line"><span class="comment"> * &#123;% link 链接,标题,图标,介绍 %&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> defaultIcon = <span class="string">&#x27;&lt;svg t=&quot;1670307855063&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;19066&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M504.064 516.608m-384.256 0a384.256 384.256 0 1 0 768.512 0 384.256 384.256 0 1 0-768.512 0Z&quot; fill=&quot;#009CF5&quot; p-id=&quot;19068&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M746.112 270.464L472.448 485.12l63.104 63.104L750.08 274.56c2.304-2.688-1.28-6.144-3.968-4.096z&quot; fill=&quot;#FF4C3A&quot; p-id=&quot;19069&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M262.016 762.752l273.664-214.528-63.104-63.104-214.656 273.536c-2.176 2.688 1.28 6.144 4.096 4.096z&quot; fill=&quot;#FFFFFF&quot; p-id=&quot;19070&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M505.216 155.136c-3.2 0-5.888 2.56-5.888 5.888v53.504c0 3.2 2.56 5.888 5.888 5.888s5.888-2.56 5.888-5.888v-53.504c-0.128-3.2-2.688-5.888-5.888-5.888zM442.368 160.512c-3.2 0.512-5.376 3.584-4.736 6.784l9.344 52.736c0.512 3.2 3.584 5.376 6.784 4.736 3.2-0.512 5.376-3.584 4.736-6.784l-9.344-52.736c-0.512-3.2-3.584-5.376-6.784-4.736zM396.288 234.368c1.152 3.072 4.48 4.608 7.552 3.456 3.072-1.152 4.608-4.48 3.456-7.552l-18.304-50.304c-1.152-3.072-4.48-4.608-7.552-3.456-3.072 1.152-4.608 4.48-3.456 7.552l18.304 50.304zM348.928 257.408c1.664 2.816 5.248 3.712 7.936 2.176s3.712-5.248 2.176-7.936l-26.752-46.336c-1.664-2.816-5.248-3.712-7.936-2.176-2.816 1.664-3.712 5.248-2.176 7.936l26.752 46.336zM306.304 288.256c2.048 2.432 5.76 2.816 8.192 0.768 2.432-2.048 2.816-5.76 0.768-8.192l-34.432-40.96c-2.048-2.432-5.76-2.816-8.192-0.768-2.432 2.048-2.816 5.76-0.768 8.192l34.432 40.96zM269.696 326.144c2.432 2.048 6.144 1.792 8.192-0.768 2.048-2.432 1.792-6.144-0.768-8.192l-40.96-34.432c-2.432-2.048-6.144-1.792-8.192 0.768-2.048 2.432-1.792 6.144 0.768 8.192l40.96 34.432zM193.792 342.912l46.336 26.752c2.816 1.664 6.4 0.64 7.936-2.176 1.664-2.816 0.64-6.4-2.176-8.064L199.552 332.8c-2.816-1.664-6.4-0.64-7.936 2.176-1.664 2.688-0.64 6.272 2.176 7.936zM168.32 399.488l50.304 18.304c3.072 1.152 6.4-0.512 7.552-3.456 1.152-3.072-0.512-6.4-3.456-7.552l-50.304-18.304c-3.072-1.152-6.4 0.512-7.552 3.456-1.152 3.072 0.384 6.4 3.456 7.552zM207.872 457.344l-52.736-9.344c-3.2-0.512-6.272 1.536-6.784 4.736-0.512 3.2 1.536 6.272 4.736 6.784l52.736 9.344c3.2 0.512 6.272-1.536 6.784-4.736 0.512-3.2-1.536-6.272-4.736-6.784zM201.984 509.568H148.48c-3.2 0-5.888 2.56-5.888 5.888 0 3.2 2.56 5.888 5.888 5.888h53.504c3.2 0 5.888-2.56 5.888-5.888 0-3.2-2.56-5.888-5.888-5.888zM205.44 562.176l-52.736 9.344c-3.2 0.512-5.376 3.584-4.736 6.784 0.512 3.2 3.584 5.376 6.784 4.736l52.736-9.344c3.2-0.512 5.376-3.584 4.736-6.784s-3.584-5.248-6.784-4.736zM217.856 613.376l-50.304 18.304c-3.072 1.152-4.608 4.48-3.456 7.552 1.152 3.072 4.48 4.608 7.552 3.456l50.304-18.304c3.072-1.152 4.608-4.48 3.456-7.552-1.152-3.072-4.48-4.608-7.552-3.456zM238.976 661.504l-46.336 26.752c-2.816 1.664-3.712 5.248-2.176 8.064 1.664 2.816 5.248 3.712 8.064 2.176l46.336-26.752c2.816-1.664 3.712-5.248 2.176-8.064-1.664-2.816-5.248-3.712-8.064-2.176zM268.16 705.408l-40.96 34.432c-2.432 2.048-2.816 5.76-0.768 8.192 2.048 2.432 5.76 2.816 8.192 0.768l40.96-34.432c2.432-2.048 2.816-5.76 0.768-8.192-1.92-2.56-5.632-2.816-8.192-0.768zM304.512 743.424l-34.432 40.96c-2.048 2.432-1.792 6.144 0.768 8.192 2.432 2.048 6.144 1.792 8.192-0.768l34.432-40.96c2.048-2.432 1.792-6.144-0.768-8.192-2.304-1.92-6.016-1.664-8.192 0.768zM347.008 774.656l-26.752 46.336c-1.664 2.816-0.64 6.4 2.176 7.936 2.816 1.664 6.4 0.64 8.064-2.176l26.752-46.336c1.664-2.816 0.64-6.4-2.176-7.936-2.816-1.536-6.4-0.64-8.064 2.176zM394.24 798.08l-18.304 50.304c-1.152 3.072 0.512 6.4 3.456 7.552 3.072 1.152 6.4-0.512 7.552-3.456l18.304-50.304c1.152-3.072-0.512-6.4-3.456-7.552-3.072-1.152-6.528 0.384-7.552 3.456zM440.192 872.32c3.2 0.512 6.272-1.536 6.784-4.736l9.344-52.736c0.512-3.2-1.536-6.272-4.736-6.784-3.2-0.512-6.272 1.536-6.784 4.736l-9.344 52.736c-0.64 3.2 1.536 6.272 4.736 6.784zM502.912 878.08c3.2 0 5.888-2.56 5.888-5.888v-53.504c0-3.2-2.56-5.888-5.888-5.888-3.2 0-5.888 2.56-5.888 5.888v53.504c0 3.2 2.688 5.888 5.888 5.888zM549.632 815.232l9.344 52.736c0.512 3.2 3.584 5.376 6.784 4.736 3.2-0.512 5.376-3.584 4.736-6.784l-9.344-52.736c-0.512-3.2-3.584-5.376-6.784-4.736-3.2 0.512-5.248 3.584-4.736 6.784zM600.832 802.816l18.304 50.304c1.152 3.072 4.48 4.608 7.552 3.456 3.072-1.152 4.608-4.48 3.456-7.552L611.84 798.72c-1.152-3.072-4.48-4.608-7.552-3.456-3.072 1.152-4.608 4.48-3.456 7.552zM649.088 781.696l26.752 46.336c1.664 2.816 5.248 3.712 8.064 2.176 2.816-1.664 3.712-5.248 2.176-8.064l-26.88-46.336c-1.664-2.816-5.248-3.712-8.064-2.176-2.816 1.664-3.712 5.248-2.048 8.064zM692.864 752.384l34.432 40.96c2.048 2.432 5.76 2.816 8.192 0.768 2.432-2.048 2.816-5.76 0.768-8.192l-34.432-40.96c-2.048-2.432-5.76-2.816-8.192-0.768-2.56 2.048-2.816 5.76-0.768 8.192zM730.88 716.032l40.96 34.432c2.432 2.048 6.144 1.792 8.192-0.768 2.048-2.432 1.792-6.144-0.768-8.192l-40.96-34.432c-2.432-2.048-6.144-1.792-8.192 0.768-1.92 2.432-1.664 6.144 0.768 8.192zM762.112 673.664l46.336 26.752c2.816 1.664 6.4 0.64 8.064-2.176 1.664-2.816 0.64-6.4-2.176-7.936L768 663.552c-2.816-1.664-6.4-0.64-8.064 2.176-1.536 2.688-0.64 6.272 2.176 7.936zM785.536 626.432l50.304 18.304c3.072 1.152 6.4-0.512 7.552-3.456 1.152-3.072-0.512-6.4-3.456-7.552l-50.304-18.304c-3.072-1.152-6.4 0.512-7.552 3.456-1.152 3.072 0.384 6.4 3.456 7.552zM800.256 575.872l52.736 9.344c3.2 0.512 6.272-1.536 6.784-4.736 0.512-3.2-1.536-6.272-4.736-6.784l-52.736-9.344c-3.2-0.512-6.272 1.536-6.784 4.736-0.512 3.2 1.536 6.272 4.736 6.784zM800.256 517.76c0 3.2 2.56 5.888 5.888 5.888h53.504c3.2 0 5.888-2.56 5.888-5.888 0-3.2-2.56-5.888-5.888-5.888h-53.504c-3.328 0-5.888 2.56-5.888 5.888zM802.688 471.04l52.736-9.344c3.2-0.512 5.376-3.584 4.736-6.784-0.512-3.2-3.584-5.376-6.784-4.736l-52.736 9.344c-3.2 0.512-5.376 3.584-4.736 6.784 0.512 3.2 3.584 5.248 6.784 4.736zM790.272 419.84l50.304-18.304c3.072-1.152 4.608-4.48 3.456-7.552-1.152-3.072-4.48-4.608-7.552-3.456l-50.304 18.304c-3.072 1.152-4.608 4.48-3.456 7.552 1.152 2.944 4.48 4.608 7.552 3.456zM769.152 371.584l46.336-26.752c2.816-1.664 3.712-5.248 2.176-7.936-1.664-2.816-5.248-3.712-8.064-2.176l-46.336 26.752c-2.816 1.664-3.712 5.248-2.176 8.064 1.664 2.688 5.248 3.712 8.064 2.048zM739.84 327.808l40.96-34.432c2.432-2.048 2.816-5.76 0.768-8.192-2.048-2.432-5.76-2.816-8.192-0.768l-40.96 34.432c-2.432 2.048-2.816 5.76-0.768 8.192 2.048 2.56 5.76 2.816 8.192 0.768zM703.488 289.664l34.432-40.96c2.048-2.432 1.792-6.144-0.768-8.192-2.432-2.048-6.144-1.792-8.192 0.768l-34.432 40.96c-2.048 2.432-1.792 6.144 0.768 8.192 2.432 2.048 6.144 1.792 8.192-0.768zM661.12 258.56l26.752-46.336c1.664-2.816 0.64-6.4-2.176-7.936-2.816-1.664-6.4-0.64-8.064 2.176l-26.752 46.336c-1.664 2.816-0.64 6.4 2.176 7.936 2.816 1.536 6.4 0.64 8.064-2.176zM613.888 235.136l18.304-50.304c1.152-3.072-0.512-6.4-3.456-7.552-3.072-1.152-6.4 0.512-7.552 3.456L602.88 231.168c-1.152 3.072 0.512 6.4 3.456 7.552 3.072 1.024 6.4-0.512 7.552-3.584zM556.544 225.152c3.2 0.512 6.272-1.536 6.784-4.736l9.344-52.736c0.512-3.2-1.536-6.272-4.736-6.784-3.2-0.512-6.272 1.536-6.784 4.736l-9.344 52.736c-0.512 3.2 1.536 6.144 4.736 6.784zM273.536 290.432c2.432 2.432 6.528 2.432 8.96 0 2.432-2.432 2.432-6.528 0-8.96l-21.12-21.12c-2.432-2.432-6.528-2.432-8.96 0-2.432 2.432-2.432 6.528 0 8.96l21.12 21.12zM237.824 333.824c2.944 2.048 6.912 1.28 8.832-1.536 2.048-2.944 1.28-6.912-1.536-8.832l-24.448-17.152c-2.944-2.048-6.912-1.28-8.832 1.536s-1.28 6.912 1.536 8.832l24.448 17.152zM183.04 370.176l27.136 12.672c3.2 1.536 7.04 0.128 8.448-3.072 1.536-3.2 0.128-7.04-3.072-8.448l-27.136-12.672c-3.2-1.536-7.04-0.128-8.448 3.072-1.536 3.2-0.128 7.04 3.072 8.448zM194.688 423.68l-28.928-7.68c-3.456-0.896-6.912 1.152-7.808 4.48-0.896 3.456 1.152 6.912 4.48 7.808l28.928 7.68c3.456 0.896 6.912-1.152 7.808-4.48 0.896-3.456-1.152-6.912-4.48-7.808zM183.168 478.72l-29.824-2.56c-3.456-0.256-6.656 2.304-6.912 5.76-0.256 3.456 2.304 6.656 5.76 6.912l29.824 2.56c3.456 0.256 6.656-2.304 6.912-5.76 0.384-3.456-2.176-6.528-5.76-6.912zM181.504 535.04l-29.824 2.56c-3.456 0.256-6.144 3.456-5.76 6.912 0.256 3.456 3.456 6.144 6.912 5.76l29.824-2.56c3.456-0.256 6.144-3.456 5.76-6.912-0.256-3.456-3.328-6.016-6.912-5.76zM191.36 590.72l-28.928 7.68c-3.456 0.896-5.376 4.352-4.48 7.808 0.896 3.456 4.352 5.376 7.808 4.48l28.928-7.68c3.456-0.896 5.376-4.352 4.48-7.808-0.896-3.328-4.352-5.376-7.808-4.48zM207.232 644.224l-27.136 12.672c-3.2 1.536-4.608 5.248-3.072 8.448 1.536 3.2 5.248 4.608 8.448 3.072l27.136-12.672c3.2-1.536 4.608-5.248 3.072-8.448-1.408-3.2-5.248-4.48-8.448-3.072zM233.984 693.888l-24.448 17.152c-2.944 2.048-3.584 6.016-1.536 8.832 2.048 2.944 6.016 3.584 8.832 1.536l24.448-17.152c2.944-2.048 3.584-6.016 1.536-8.832-2.048-2.944-6.016-3.584-8.832-1.536zM310.912 775.552L293.76 800c-2.048 2.944-1.28 6.912 1.536 8.832 2.944 2.048 6.912 1.28 8.832-1.536l17.152-24.448c2.048-2.944 1.28-6.912-1.536-8.832-2.816-2.048-6.912-1.408-8.832 1.536zM349.184 840.704c3.2 1.536 7.04 0.128 8.448-3.072l12.672-27.136c1.536-3.2 0.128-7.04-3.072-8.448-3.2-1.536-7.04-0.128-8.448 3.072l-12.672 27.136c-1.408 3.2-0.128 6.912 3.072 8.448zM407.808 862.72c3.456 0.896 6.912-1.152 7.808-4.48l7.68-28.928c0.896-3.456-1.152-6.912-4.48-7.808-3.456-0.896-6.912 1.152-7.808 4.48l-7.68 28.928c-0.896 3.328 1.152 6.912 4.48 7.808zM469.376 874.112c3.456 0.256 6.656-2.304 6.912-5.76l2.56-29.824c0.256-3.456-2.304-6.656-5.76-6.912-3.456-0.256-6.656 2.304-6.912 5.76l-2.56 29.824c-0.256 3.584 2.304 6.656 5.76 6.912zM522.496 839.168l2.56 29.824c0.256 3.456 3.456 6.144 6.912 5.76 3.456-0.256 6.144-3.456 5.76-6.912l-2.56-29.824c-0.256-3.456-3.456-6.144-6.912-5.76-3.456 0.256-6.016 3.328-5.76 6.912zM578.176 830.976l7.68 28.928c0.896 3.456 4.352 5.376 7.808 4.48 3.456-0.896 5.376-4.352 4.48-7.808l-7.68-28.928c-0.896-3.456-4.352-5.376-7.808-4.48-3.328 0.896-5.376 4.48-4.48 7.808zM631.68 813.312l12.672 27.136c1.536 3.2 5.248 4.608 8.448 3.072 3.2-1.536 4.608-5.248 3.072-8.448l-12.672-27.136c-1.536-3.2-5.248-4.608-8.448-3.072-3.2 1.536-4.48 5.248-3.072 8.448zM681.344 786.688l17.152 24.448c2.048 2.944 6.016 3.584 8.832 1.536 2.944-2.048 3.584-6.016 1.536-8.832l-17.152-24.448c-2.048-2.944-6.016-3.584-8.832-1.536-2.944 1.92-3.584 5.888-1.536 8.832zM725.504 751.744l21.12 21.12c2.432 2.432 6.528 2.432 8.96 0 2.432-2.432 2.432-6.528 0-8.96l-21.12-21.12c-2.432-2.432-6.528-2.432-8.96 0-2.432 2.432-2.432 6.528 0 8.96zM763.008 709.76l24.448 17.152c2.944 2.048 6.912 1.28 8.832-1.536 2.048-2.944 1.28-6.912-1.536-8.832l-24.448-17.152c-2.944-2.048-6.912-1.28-8.832 1.536-2.048 2.816-1.408 6.784 1.536 8.832zM792.576 661.888l27.136 12.672c3.2 1.536 7.04 0.128 8.448-3.072 1.536-3.2 0.128-7.04-3.072-8.448l-27.136-12.672c-3.2-1.536-7.04-0.128-8.448 3.072-1.536 3.2-0.128 6.912 3.072 8.448zM813.44 609.536l28.928 7.68c3.456 0.896 6.912-1.152 7.808-4.48 0.896-3.456-1.152-6.912-4.48-7.808l-28.928-7.68c-3.456-0.896-6.912 1.152-7.808 4.48-0.896 3.456 1.024 6.912 4.48 7.808zM824.832 554.368l29.824 2.56c3.456 0.256 6.656-2.304 6.912-5.76 0.256-3.456-2.304-6.656-5.76-6.912l-29.824-2.56c-3.456-0.256-6.656 2.304-6.912 5.76-0.256 3.584 2.304 6.656 5.76 6.912zM826.624 498.176l29.824-2.56c3.456-0.256 6.144-3.456 5.76-6.912-0.256-3.456-3.456-6.144-6.912-5.76l-29.824 2.56c-3.456 0.256-6.144 3.456-5.76 6.912 0.256 3.456 3.328 6.016 6.912 5.76zM818.432 442.368l28.928-7.68c3.456-0.896 5.376-4.352 4.48-7.808-0.896-3.456-4.352-5.376-7.808-4.48l-28.928 7.68c-3.456 0.896-5.376 4.352-4.48 7.808 0.896 3.456 4.48 5.376 7.808 4.48zM800.768 388.992l27.136-12.672c3.2-1.536 4.608-5.248 3.072-8.448-1.536-3.2-5.248-4.608-8.448-3.072l-27.136 12.672c-3.2 1.536-4.608 5.248-3.072 8.448 1.536 3.072 5.248 4.48 8.448 3.072zM774.144 339.328l24.448-17.152c2.944-2.048 3.584-6.016 1.536-8.832-2.048-2.944-6.016-3.584-8.832-1.536L766.848 328.96c-2.944 2.048-3.584 6.016-1.536 8.832 1.92 2.816 5.888 3.584 8.832 1.536zM697.216 257.664l17.152-24.448c2.048-2.944 1.28-6.912-1.536-8.832-2.944-2.048-6.912-1.28-8.832 1.536l-17.152 24.448c-2.048 2.944-1.28 6.912 1.536 8.832 2.816 2.048 6.784 1.408 8.832-1.536zM658.944 192.512c-3.2-1.536-7.04-0.128-8.448 3.072l-12.672 27.136c-1.536 3.2-0.128 7.04 3.072 8.448 3.2 1.536 7.04 0.128 8.448-3.072l12.672-27.136c1.408-3.2 0-7.04-3.072-8.448zM600.192 170.496c-3.456-0.896-6.912 1.152-7.808 4.48l-7.68 28.928c-0.896 3.456 1.152 6.912 4.48 7.808 3.456 0.896 6.912-1.152 7.808-4.48l7.68-28.928c1.024-3.328-1.024-6.912-4.48-7.808zM534.912 201.6c3.456 0.256 6.656-2.304 6.912-5.76l2.56-29.824c0.256-3.456-2.304-6.656-5.76-6.912-3.456-0.256-6.656 2.304-6.912 5.76l-2.56 29.824c-0.256 3.456 2.304 6.528 5.76 6.912zM476.032 158.464c-3.456 0.256-6.144 3.456-5.76 6.912l2.56 29.824c0.256 3.456 3.456 6.144 6.912 5.76 3.456-0.256 6.144-3.456 5.76-6.912l-2.56-29.824c-0.256-3.456-3.328-6.016-6.912-5.76zM422.144 173.312c-0.896-3.456-4.352-5.376-7.808-4.48-3.456 0.896-5.376 4.352-4.48 7.808l7.68 28.928c0.896 3.456 4.352 5.376 7.808 4.48 3.456-0.896 5.376-4.352 4.48-7.808l-7.68-28.928zM376.448 219.776l-12.672-27.136c-1.536-3.2-5.248-4.608-8.448-3.072-3.2 1.536-4.608 5.248-3.072 8.448L364.8 225.28c1.536 3.2 5.248 4.608 8.448 3.072 3.2-1.536 4.608-5.376 3.2-8.576zM316.416 253.824c2.048 2.944 6.016 3.584 8.832 1.536 2.944-2.048 3.584-6.016 1.536-8.832l-17.152-24.448c-2.048-2.944-6.016-3.584-8.832-1.536-2.944 2.048-3.584 6.016-1.536 8.832l17.152 24.448z&quot; fill=&quot;#FFFFFF&quot; p-id=&quot;19071&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">link</span>(<span class="params">args</span>) &#123;</span><br><span class="line">    args = args.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">let</span> url = (args[<span class="number">0</span>] || <span class="string">&#x27;&#x27;</span>).<span class="title function_">trim</span>(),</span><br><span class="line">        title = (args[<span class="number">1</span>] || <span class="string">&#x27;点击直达链接&#x27;</span>).<span class="title function_">trim</span>(),</span><br><span class="line">        favicon = (args[<span class="number">2</span>] ? <span class="string">`&lt;img src=&quot;<span class="subst">$&#123;args[<span class="number">2</span>]&#125;</span>&quot; class=&quot;no-lightbox&quot;&gt;`</span> : defaultIcon).<span class="title function_">trim</span>(),</span><br><span class="line">        desc = (args[<span class="number">3</span>] || <span class="string">&#x27;&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;a href=&quot;<span class="subst">$&#123;url&#125;</span>&quot; <span class="subst">$&#123;url.includes(<span class="string">&#x27;http&#x27;</span>)?<span class="string">&#x27;target=&quot;_blank&quot;&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span> title=&quot;<span class="subst">$&#123;title&#125;</span>&quot; referrerPolicy=&quot;no-referrer&quot; class=&quot;link_card&quot;&gt;&lt;div class=&quot;link_icon&quot;&gt;<span class="subst">$&#123;favicon&#125;</span>&lt;/div&gt;&lt;div class=&quot;link_content&quot;&gt;&lt;div class=&quot;link_title&quot;&gt;<span class="subst">$&#123;title&#125;</span>&lt;/div&gt;<span class="subst">$&#123;desc?<span class="string">`&lt;div class=&quot;link_desc&quot;&gt;<span class="subst">$&#123;desc&#125;</span>&lt;/div&gt;`</span>:<span class="string">&#x27;&#x27;</span>&#125;</span>&lt;/div&gt;&lt;/a&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">tag</span>.<span class="title function_">register</span>(<span class="string">&#x27;link&#x27;</span>, link, &#123; <span class="attr">ends</span>: <span class="literal">false</span> &#125;)</span><br></pre></td></tr></table></figure><h2 id="引入样式文件"><a href="#引入样式文件" class="headerlink" title="引入样式文件"></a>引入样式文件</h2><p>找到 <code>node_modules/hexo-theme-butterfly/source/css/_tags</code> 文件夹，在目录下创建 <code>link.styl</code> 文件。</p><p>其内容如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.link_card</span></span><br><span class="line">  <span class="attribute">display</span>: flex</span><br><span class="line">  margin: <span class="number">10px</span> <span class="number">0</span></span><br><span class="line">  color: <span class="built_in">var</span>(--font-color) <span class="meta">!important</span></span><br><span class="line">  text-decoration: none <span class="meta">!important</span></span><br><span class="line">  background: <span class="built_in">var</span>(--reward-pop)</span><br><span class="line">  border-radius: <span class="number">10px</span></span><br><span class="line">  padding: <span class="number">12px</span></span><br><span class="line">  &amp;:hover</span><br><span class="line">    background: <span class="number">#9370DB</span> <span class="comment">/* 鼠标悬浮时的颜色, 可自定义修改 */</span></span><br><span class="line">    color: white <span class="meta">!important</span></span><br><span class="line">  .link_icon,.link_content</span><br><span class="line">    height: <span class="number">4rem</span></span><br><span class="line">  .link_icon</span><br><span class="line">    img,svg</span><br><span class="line">      height: <span class="number">4rem</span></span><br><span class="line">      width: <span class="number">4rem</span></span><br><span class="line">  .link_content</span><br><span class="line">    margin-left: <span class="number">1rem</span></span><br><span class="line">    width: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">6rem</span>)</span><br><span class="line">    overflow: hidden</span><br><span class="line">    line-height: <span class="number">1.5</span></span><br><span class="line">    display: flex</span><br><span class="line">    flex-direction: column</span><br><span class="line">    justify-content: center</span><br><span class="line">    .link_title</span><br><span class="line">      font-weight: bold</span><br><span class="line">      font-size: <span class="number">1.2rem</span></span><br><span class="line">    .link_title,.link_desc</span><br><span class="line">      word-break: break-all</span><br><span class="line">      overflow:hidden</span><br><span class="line">      text-overflow: ellipsis</span><br><span class="line">    &amp;:<span class="built_in">not</span>(:<span class="built_in">has</span>(.link_desc)) .link_title</span><br><span class="line">      display:-webkit-box</span><br><span class="line">      -webkit-box-orient:vertical</span><br><span class="line">      -webkit-line-clamp:<span class="number">2</span></span><br><span class="line">    .link_desc</span><br><span class="line">      opacity: .<span class="number">6</span></span><br><span class="line">    .link_desc,&amp;:<span class="built_in">has</span>(.link_desc) .link_title</span><br><span class="line">      white-space: nowrap</span><br></pre></td></tr></table></figure><h1 id="使用卡片链接"><a href="#使用卡片链接" class="headerlink" title="使用卡片链接"></a>使用卡片链接</h1><h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 链接, 标题, 图标, 描述 %&#125;</span><br><span class="line"></span><br><span class="line">如: &#123;% link www.baidu.com, 百度, www.baidu.com/favicon/ico, 这是描述 %&#125;</span><br></pre></td></tr></table></figure><style>table th:nth-of-type(1) {    text-align: center;    width: 60px;}table th:nth-of-type(2) {    width: 200px;}</style><table><thead><tr><th align="center">参数</th><th>描述</th></tr></thead><tbody><tr><td align="center">链接</td><td>如果连接中包含 http 则新标签打开，否则本标签页打开</td></tr><tr><td align="center">标题</td><td>链接的标题</td></tr><tr><td align="center">图标</td><td>网站的 ico 图标</td></tr><tr><td align="center">描述</td><td>网站的描述信息</td></tr></tbody></table><h2 id="效果展示-1"><a href="#效果展示-1" class="headerlink" title="效果展示"></a>效果展示</h2><ul><li>完整参数的效果展示</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link https://gitee.com, Gitee, https://gitee.com/favicon.ico, 这是 Gitee %&#125;</span><br></pre></td></tr></table></figure><a href="https://gitee.com" target="_blank" title="Gitee" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src=" https://gitee.com/favicon.ico" class="no-lightbox"></div><div class="link_content"><div class="link_title">Gitee</div><div class="link_desc">这是 Gitee</div></div></a><ul><li>只添加链接的展示</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link https://gitee.com %&#125;</span><br></pre></td></tr></table></figure><a href="https://gitee.com" target="_blank" title="点击直达链接" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><svg t="1670307855063" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="19066" width="200" height="200"><path d="M504.064 516.608m-384.256 0a384.256 384.256 0 1 0 768.512 0 384.256 384.256 0 1 0-768.512 0Z" fill="#009CF5" p-id="19068"></path><path d="M746.112 270.464L472.448 485.12l63.104 63.104L750.08 274.56c2.304-2.688-1.28-6.144-3.968-4.096z" fill="#FF4C3A" p-id="19069"></path><path d="M262.016 762.752l273.664-214.528-63.104-63.104-214.656 273.536c-2.176 2.688 1.28 6.144 4.096 4.096z" fill="#FFFFFF" p-id="19070"></path><path d="M505.216 155.136c-3.2 0-5.888 2.56-5.888 5.888v53.504c0 3.2 2.56 5.888 5.888 5.888s5.888-2.56 5.888-5.888v-53.504c-0.128-3.2-2.688-5.888-5.888-5.888zM442.368 160.512c-3.2 0.512-5.376 3.584-4.736 6.784l9.344 52.736c0.512 3.2 3.584 5.376 6.784 4.736 3.2-0.512 5.376-3.584 4.736-6.784l-9.344-52.736c-0.512-3.2-3.584-5.376-6.784-4.736zM396.288 234.368c1.152 3.072 4.48 4.608 7.552 3.456 3.072-1.152 4.608-4.48 3.456-7.552l-18.304-50.304c-1.152-3.072-4.48-4.608-7.552-3.456-3.072 1.152-4.608 4.48-3.456 7.552l18.304 50.304zM348.928 257.408c1.664 2.816 5.248 3.712 7.936 2.176s3.712-5.248 2.176-7.936l-26.752-46.336c-1.664-2.816-5.248-3.712-7.936-2.176-2.816 1.664-3.712 5.248-2.176 7.936l26.752 46.336zM306.304 288.256c2.048 2.432 5.76 2.816 8.192 0.768 2.432-2.048 2.816-5.76 0.768-8.192l-34.432-40.96c-2.048-2.432-5.76-2.816-8.192-0.768-2.432 2.048-2.816 5.76-0.768 8.192l34.432 40.96zM269.696 326.144c2.432 2.048 6.144 1.792 8.192-0.768 2.048-2.432 1.792-6.144-0.768-8.192l-40.96-34.432c-2.432-2.048-6.144-1.792-8.192 0.768-2.048 2.432-1.792 6.144 0.768 8.192l40.96 34.432zM193.792 342.912l46.336 26.752c2.816 1.664 6.4 0.64 7.936-2.176 1.664-2.816 0.64-6.4-2.176-8.064L199.552 332.8c-2.816-1.664-6.4-0.64-7.936 2.176-1.664 2.688-0.64 6.272 2.176 7.936zM168.32 399.488l50.304 18.304c3.072 1.152 6.4-0.512 7.552-3.456 1.152-3.072-0.512-6.4-3.456-7.552l-50.304-18.304c-3.072-1.152-6.4 0.512-7.552 3.456-1.152 3.072 0.384 6.4 3.456 7.552zM207.872 457.344l-52.736-9.344c-3.2-0.512-6.272 1.536-6.784 4.736-0.512 3.2 1.536 6.272 4.736 6.784l52.736 9.344c3.2 0.512 6.272-1.536 6.784-4.736 0.512-3.2-1.536-6.272-4.736-6.784zM201.984 509.568H148.48c-3.2 0-5.888 2.56-5.888 5.888 0 3.2 2.56 5.888 5.888 5.888h53.504c3.2 0 5.888-2.56 5.888-5.888 0-3.2-2.56-5.888-5.888-5.888zM205.44 562.176l-52.736 9.344c-3.2 0.512-5.376 3.584-4.736 6.784 0.512 3.2 3.584 5.376 6.784 4.736l52.736-9.344c3.2-0.512 5.376-3.584 4.736-6.784s-3.584-5.248-6.784-4.736zM217.856 613.376l-50.304 18.304c-3.072 1.152-4.608 4.48-3.456 7.552 1.152 3.072 4.48 4.608 7.552 3.456l50.304-18.304c3.072-1.152 4.608-4.48 3.456-7.552-1.152-3.072-4.48-4.608-7.552-3.456zM238.976 661.504l-46.336 26.752c-2.816 1.664-3.712 5.248-2.176 8.064 1.664 2.816 5.248 3.712 8.064 2.176l46.336-26.752c2.816-1.664 3.712-5.248 2.176-8.064-1.664-2.816-5.248-3.712-8.064-2.176zM268.16 705.408l-40.96 34.432c-2.432 2.048-2.816 5.76-0.768 8.192 2.048 2.432 5.76 2.816 8.192 0.768l40.96-34.432c2.432-2.048 2.816-5.76 0.768-8.192-1.92-2.56-5.632-2.816-8.192-0.768zM304.512 743.424l-34.432 40.96c-2.048 2.432-1.792 6.144 0.768 8.192 2.432 2.048 6.144 1.792 8.192-0.768l34.432-40.96c2.048-2.432 1.792-6.144-0.768-8.192-2.304-1.92-6.016-1.664-8.192 0.768zM347.008 774.656l-26.752 46.336c-1.664 2.816-0.64 6.4 2.176 7.936 2.816 1.664 6.4 0.64 8.064-2.176l26.752-46.336c1.664-2.816 0.64-6.4-2.176-7.936-2.816-1.536-6.4-0.64-8.064 2.176zM394.24 798.08l-18.304 50.304c-1.152 3.072 0.512 6.4 3.456 7.552 3.072 1.152 6.4-0.512 7.552-3.456l18.304-50.304c1.152-3.072-0.512-6.4-3.456-7.552-3.072-1.152-6.528 0.384-7.552 3.456zM440.192 872.32c3.2 0.512 6.272-1.536 6.784-4.736l9.344-52.736c0.512-3.2-1.536-6.272-4.736-6.784-3.2-0.512-6.272 1.536-6.784 4.736l-9.344 52.736c-0.64 3.2 1.536 6.272 4.736 6.784zM502.912 878.08c3.2 0 5.888-2.56 5.888-5.888v-53.504c0-3.2-2.56-5.888-5.888-5.888-3.2 0-5.888 2.56-5.888 5.888v53.504c0 3.2 2.688 5.888 5.888 5.888zM549.632 815.232l9.344 52.736c0.512 3.2 3.584 5.376 6.784 4.736 3.2-0.512 5.376-3.584 4.736-6.784l-9.344-52.736c-0.512-3.2-3.584-5.376-6.784-4.736-3.2 0.512-5.248 3.584-4.736 6.784zM600.832 802.816l18.304 50.304c1.152 3.072 4.48 4.608 7.552 3.456 3.072-1.152 4.608-4.48 3.456-7.552L611.84 798.72c-1.152-3.072-4.48-4.608-7.552-3.456-3.072 1.152-4.608 4.48-3.456 7.552zM649.088 781.696l26.752 46.336c1.664 2.816 5.248 3.712 8.064 2.176 2.816-1.664 3.712-5.248 2.176-8.064l-26.88-46.336c-1.664-2.816-5.248-3.712-8.064-2.176-2.816 1.664-3.712 5.248-2.048 8.064zM692.864 752.384l34.432 40.96c2.048 2.432 5.76 2.816 8.192 0.768 2.432-2.048 2.816-5.76 0.768-8.192l-34.432-40.96c-2.048-2.432-5.76-2.816-8.192-0.768-2.56 2.048-2.816 5.76-0.768 8.192zM730.88 716.032l40.96 34.432c2.432 2.048 6.144 1.792 8.192-0.768 2.048-2.432 1.792-6.144-0.768-8.192l-40.96-34.432c-2.432-2.048-6.144-1.792-8.192 0.768-1.92 2.432-1.664 6.144 0.768 8.192zM762.112 673.664l46.336 26.752c2.816 1.664 6.4 0.64 8.064-2.176 1.664-2.816 0.64-6.4-2.176-7.936L768 663.552c-2.816-1.664-6.4-0.64-8.064 2.176-1.536 2.688-0.64 6.272 2.176 7.936zM785.536 626.432l50.304 18.304c3.072 1.152 6.4-0.512 7.552-3.456 1.152-3.072-0.512-6.4-3.456-7.552l-50.304-18.304c-3.072-1.152-6.4 0.512-7.552 3.456-1.152 3.072 0.384 6.4 3.456 7.552zM800.256 575.872l52.736 9.344c3.2 0.512 6.272-1.536 6.784-4.736 0.512-3.2-1.536-6.272-4.736-6.784l-52.736-9.344c-3.2-0.512-6.272 1.536-6.784 4.736-0.512 3.2 1.536 6.272 4.736 6.784zM800.256 517.76c0 3.2 2.56 5.888 5.888 5.888h53.504c3.2 0 5.888-2.56 5.888-5.888 0-3.2-2.56-5.888-5.888-5.888h-53.504c-3.328 0-5.888 2.56-5.888 5.888zM802.688 471.04l52.736-9.344c3.2-0.512 5.376-3.584 4.736-6.784-0.512-3.2-3.584-5.376-6.784-4.736l-52.736 9.344c-3.2 0.512-5.376 3.584-4.736 6.784 0.512 3.2 3.584 5.248 6.784 4.736zM790.272 419.84l50.304-18.304c3.072-1.152 4.608-4.48 3.456-7.552-1.152-3.072-4.48-4.608-7.552-3.456l-50.304 18.304c-3.072 1.152-4.608 4.48-3.456 7.552 1.152 2.944 4.48 4.608 7.552 3.456zM769.152 371.584l46.336-26.752c2.816-1.664 3.712-5.248 2.176-7.936-1.664-2.816-5.248-3.712-8.064-2.176l-46.336 26.752c-2.816 1.664-3.712 5.248-2.176 8.064 1.664 2.688 5.248 3.712 8.064 2.048zM739.84 327.808l40.96-34.432c2.432-2.048 2.816-5.76 0.768-8.192-2.048-2.432-5.76-2.816-8.192-0.768l-40.96 34.432c-2.432 2.048-2.816 5.76-0.768 8.192 2.048 2.56 5.76 2.816 8.192 0.768zM703.488 289.664l34.432-40.96c2.048-2.432 1.792-6.144-0.768-8.192-2.432-2.048-6.144-1.792-8.192 0.768l-34.432 40.96c-2.048 2.432-1.792 6.144 0.768 8.192 2.432 2.048 6.144 1.792 8.192-0.768zM661.12 258.56l26.752-46.336c1.664-2.816 0.64-6.4-2.176-7.936-2.816-1.664-6.4-0.64-8.064 2.176l-26.752 46.336c-1.664 2.816-0.64 6.4 2.176 7.936 2.816 1.536 6.4 0.64 8.064-2.176zM613.888 235.136l18.304-50.304c1.152-3.072-0.512-6.4-3.456-7.552-3.072-1.152-6.4 0.512-7.552 3.456L602.88 231.168c-1.152 3.072 0.512 6.4 3.456 7.552 3.072 1.024 6.4-0.512 7.552-3.584zM556.544 225.152c3.2 0.512 6.272-1.536 6.784-4.736l9.344-52.736c0.512-3.2-1.536-6.272-4.736-6.784-3.2-0.512-6.272 1.536-6.784 4.736l-9.344 52.736c-0.512 3.2 1.536 6.144 4.736 6.784zM273.536 290.432c2.432 2.432 6.528 2.432 8.96 0 2.432-2.432 2.432-6.528 0-8.96l-21.12-21.12c-2.432-2.432-6.528-2.432-8.96 0-2.432 2.432-2.432 6.528 0 8.96l21.12 21.12zM237.824 333.824c2.944 2.048 6.912 1.28 8.832-1.536 2.048-2.944 1.28-6.912-1.536-8.832l-24.448-17.152c-2.944-2.048-6.912-1.28-8.832 1.536s-1.28 6.912 1.536 8.832l24.448 17.152zM183.04 370.176l27.136 12.672c3.2 1.536 7.04 0.128 8.448-3.072 1.536-3.2 0.128-7.04-3.072-8.448l-27.136-12.672c-3.2-1.536-7.04-0.128-8.448 3.072-1.536 3.2-0.128 7.04 3.072 8.448zM194.688 423.68l-28.928-7.68c-3.456-0.896-6.912 1.152-7.808 4.48-0.896 3.456 1.152 6.912 4.48 7.808l28.928 7.68c3.456 0.896 6.912-1.152 7.808-4.48 0.896-3.456-1.152-6.912-4.48-7.808zM183.168 478.72l-29.824-2.56c-3.456-0.256-6.656 2.304-6.912 5.76-0.256 3.456 2.304 6.656 5.76 6.912l29.824 2.56c3.456 0.256 6.656-2.304 6.912-5.76 0.384-3.456-2.176-6.528-5.76-6.912zM181.504 535.04l-29.824 2.56c-3.456 0.256-6.144 3.456-5.76 6.912 0.256 3.456 3.456 6.144 6.912 5.76l29.824-2.56c3.456-0.256 6.144-3.456 5.76-6.912-0.256-3.456-3.328-6.016-6.912-5.76zM191.36 590.72l-28.928 7.68c-3.456 0.896-5.376 4.352-4.48 7.808 0.896 3.456 4.352 5.376 7.808 4.48l28.928-7.68c3.456-0.896 5.376-4.352 4.48-7.808-0.896-3.328-4.352-5.376-7.808-4.48zM207.232 644.224l-27.136 12.672c-3.2 1.536-4.608 5.248-3.072 8.448 1.536 3.2 5.248 4.608 8.448 3.072l27.136-12.672c3.2-1.536 4.608-5.248 3.072-8.448-1.408-3.2-5.248-4.48-8.448-3.072zM233.984 693.888l-24.448 17.152c-2.944 2.048-3.584 6.016-1.536 8.832 2.048 2.944 6.016 3.584 8.832 1.536l24.448-17.152c2.944-2.048 3.584-6.016 1.536-8.832-2.048-2.944-6.016-3.584-8.832-1.536zM310.912 775.552L293.76 800c-2.048 2.944-1.28 6.912 1.536 8.832 2.944 2.048 6.912 1.28 8.832-1.536l17.152-24.448c2.048-2.944 1.28-6.912-1.536-8.832-2.816-2.048-6.912-1.408-8.832 1.536zM349.184 840.704c3.2 1.536 7.04 0.128 8.448-3.072l12.672-27.136c1.536-3.2 0.128-7.04-3.072-8.448-3.2-1.536-7.04-0.128-8.448 3.072l-12.672 27.136c-1.408 3.2-0.128 6.912 3.072 8.448zM407.808 862.72c3.456 0.896 6.912-1.152 7.808-4.48l7.68-28.928c0.896-3.456-1.152-6.912-4.48-7.808-3.456-0.896-6.912 1.152-7.808 4.48l-7.68 28.928c-0.896 3.328 1.152 6.912 4.48 7.808zM469.376 874.112c3.456 0.256 6.656-2.304 6.912-5.76l2.56-29.824c0.256-3.456-2.304-6.656-5.76-6.912-3.456-0.256-6.656 2.304-6.912 5.76l-2.56 29.824c-0.256 3.584 2.304 6.656 5.76 6.912zM522.496 839.168l2.56 29.824c0.256 3.456 3.456 6.144 6.912 5.76 3.456-0.256 6.144-3.456 5.76-6.912l-2.56-29.824c-0.256-3.456-3.456-6.144-6.912-5.76-3.456 0.256-6.016 3.328-5.76 6.912zM578.176 830.976l7.68 28.928c0.896 3.456 4.352 5.376 7.808 4.48 3.456-0.896 5.376-4.352 4.48-7.808l-7.68-28.928c-0.896-3.456-4.352-5.376-7.808-4.48-3.328 0.896-5.376 4.48-4.48 7.808zM631.68 813.312l12.672 27.136c1.536 3.2 5.248 4.608 8.448 3.072 3.2-1.536 4.608-5.248 3.072-8.448l-12.672-27.136c-1.536-3.2-5.248-4.608-8.448-3.072-3.2 1.536-4.48 5.248-3.072 8.448zM681.344 786.688l17.152 24.448c2.048 2.944 6.016 3.584 8.832 1.536 2.944-2.048 3.584-6.016 1.536-8.832l-17.152-24.448c-2.048-2.944-6.016-3.584-8.832-1.536-2.944 1.92-3.584 5.888-1.536 8.832zM725.504 751.744l21.12 21.12c2.432 2.432 6.528 2.432 8.96 0 2.432-2.432 2.432-6.528 0-8.96l-21.12-21.12c-2.432-2.432-6.528-2.432-8.96 0-2.432 2.432-2.432 6.528 0 8.96zM763.008 709.76l24.448 17.152c2.944 2.048 6.912 1.28 8.832-1.536 2.048-2.944 1.28-6.912-1.536-8.832l-24.448-17.152c-2.944-2.048-6.912-1.28-8.832 1.536-2.048 2.816-1.408 6.784 1.536 8.832zM792.576 661.888l27.136 12.672c3.2 1.536 7.04 0.128 8.448-3.072 1.536-3.2 0.128-7.04-3.072-8.448l-27.136-12.672c-3.2-1.536-7.04-0.128-8.448 3.072-1.536 3.2-0.128 6.912 3.072 8.448zM813.44 609.536l28.928 7.68c3.456 0.896 6.912-1.152 7.808-4.48 0.896-3.456-1.152-6.912-4.48-7.808l-28.928-7.68c-3.456-0.896-6.912 1.152-7.808 4.48-0.896 3.456 1.024 6.912 4.48 7.808zM824.832 554.368l29.824 2.56c3.456 0.256 6.656-2.304 6.912-5.76 0.256-3.456-2.304-6.656-5.76-6.912l-29.824-2.56c-3.456-0.256-6.656 2.304-6.912 5.76-0.256 3.584 2.304 6.656 5.76 6.912zM826.624 498.176l29.824-2.56c3.456-0.256 6.144-3.456 5.76-6.912-0.256-3.456-3.456-6.144-6.912-5.76l-29.824 2.56c-3.456 0.256-6.144 3.456-5.76 6.912 0.256 3.456 3.328 6.016 6.912 5.76zM818.432 442.368l28.928-7.68c3.456-0.896 5.376-4.352 4.48-7.808-0.896-3.456-4.352-5.376-7.808-4.48l-28.928 7.68c-3.456 0.896-5.376 4.352-4.48 7.808 0.896 3.456 4.48 5.376 7.808 4.48zM800.768 388.992l27.136-12.672c3.2-1.536 4.608-5.248 3.072-8.448-1.536-3.2-5.248-4.608-8.448-3.072l-27.136 12.672c-3.2 1.536-4.608 5.248-3.072 8.448 1.536 3.072 5.248 4.48 8.448 3.072zM774.144 339.328l24.448-17.152c2.944-2.048 3.584-6.016 1.536-8.832-2.048-2.944-6.016-3.584-8.832-1.536L766.848 328.96c-2.944 2.048-3.584 6.016-1.536 8.832 1.92 2.816 5.888 3.584 8.832 1.536zM697.216 257.664l17.152-24.448c2.048-2.944 1.28-6.912-1.536-8.832-2.944-2.048-6.912-1.28-8.832 1.536l-17.152 24.448c-2.048 2.944-1.28 6.912 1.536 8.832 2.816 2.048 6.784 1.408 8.832-1.536zM658.944 192.512c-3.2-1.536-7.04-0.128-8.448 3.072l-12.672 27.136c-1.536 3.2-0.128 7.04 3.072 8.448 3.2 1.536 7.04 0.128 8.448-3.072l12.672-27.136c1.408-3.2 0-7.04-3.072-8.448zM600.192 170.496c-3.456-0.896-6.912 1.152-7.808 4.48l-7.68 28.928c-0.896 3.456 1.152 6.912 4.48 7.808 3.456 0.896 6.912-1.152 7.808-4.48l7.68-28.928c1.024-3.328-1.024-6.912-4.48-7.808zM534.912 201.6c3.456 0.256 6.656-2.304 6.912-5.76l2.56-29.824c0.256-3.456-2.304-6.656-5.76-6.912-3.456-0.256-6.656 2.304-6.912 5.76l-2.56 29.824c-0.256 3.456 2.304 6.528 5.76 6.912zM476.032 158.464c-3.456 0.256-6.144 3.456-5.76 6.912l2.56 29.824c0.256 3.456 3.456 6.144 6.912 5.76 3.456-0.256 6.144-3.456 5.76-6.912l-2.56-29.824c-0.256-3.456-3.328-6.016-6.912-5.76zM422.144 173.312c-0.896-3.456-4.352-5.376-7.808-4.48-3.456 0.896-5.376 4.352-4.48 7.808l7.68 28.928c0.896 3.456 4.352 5.376 7.808 4.48 3.456-0.896 5.376-4.352 4.48-7.808l-7.68-28.928zM376.448 219.776l-12.672-27.136c-1.536-3.2-5.248-4.608-8.448-3.072-3.2 1.536-4.608 5.248-3.072 8.448L364.8 225.28c1.536 3.2 5.248 4.608 8.448 3.072 3.2-1.536 4.608-5.376 3.2-8.576zM316.416 253.824c2.048 2.944 6.016 3.584 8.832 1.536 2.944-2.048 3.584-6.016 1.536-8.832l-17.152-24.448c-2.048-2.944-6.016-3.584-8.832-1.536-2.944 2.048-3.584 6.016-1.536 8.832l17.152 24.448z" fill="#FFFFFF" p-id="19071"></path></svg></div><div class="link_content"><div class="link_title">点击直达链接</div></div></a><p>该方式的默认标题为 “点击直达链接”，默认图标为左边的蓝色图标</p><ul><li>链接的写法</li></ul><p>后面的参数不填可以省略，但是中间的不填则需要留空。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link https://www.baidu.com, , , 点击进入百度 %&#125;</span><br></pre></td></tr></table></figure><a href="https://www.baidu.com" target="_blank" title="" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src=" " class="no-lightbox"></div><div class="link_content"><div class="link_title"></div><div class="link_desc">点击进入百度</div></div></a><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1、直接在 Markdown 当中写 <code>&#123;% link https://gitee.com, Gitee, https://gitee.com/favicon.ico, 这是 Gitee %&#125;</code> 即可，我使用代码块包裹是为了展示语法而已，如下图：</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250828115106688.png" alt="image-20250828115106494" style="zoom:67%;" /><p>2、链接标签解读</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250828115442325.png" alt="image-20250828115442214" style="zoom:50%;" /><h1 id="如何获取网站图标？"><a href="#如何获取网站图标？" class="headerlink" title="如何获取网站图标？"></a>如何获取网站图标？</h1><ul><li>存在 <code>favicon.ico</code> 图标的网站</li></ul><p>第一种方法：直接 F12 打开控制台，然后按照下图指引操作，最后鼠标悬停在上面即可显示图标链接。</p><blockquote><p>该方式获取的图标链接不能复制，只能自己手敲。</p></blockquote><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250828122324269.png" alt="image-20250828122324127" style="zoom:50%;" /><p>第二种方法：还是 F12 打开控制台，进入网络选项卡 (刷新页面)，找到其他，然后点击进入详情页即可获得 ico 的网址。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250828122140028.png" alt="image-20250828122139884" style="zoom:50%;" /><ul><li>没有 ico 图标的网站</li></ul><p>还是 F12 打开控制台，进入网络选项卡 (刷新页面)，找到图片或其他，查找与当前网页 icon 相符的图片即可。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250828122830777.png" alt="image-20250828122830655" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
            <tag> 卡片链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客引入 Twikoo 评论</title>
      <link href="/2025/08/27/Butterfly/Hexo%20%E5%8D%9A%E5%AE%A2%E5%BC%95%E5%85%A5%20Twikoo%20%E8%AF%84%E8%AE%BA/"/>
      <url>/2025/08/27/Butterfly/Hexo%20%E5%8D%9A%E5%AE%A2%E5%BC%95%E5%85%A5%20Twikoo%20%E8%AF%84%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E8%A9%95%E8%AB%96">Butterfly 官方文档的评论模块</a></p></blockquote><p>一开始我使用的是 <code>livere (来必力)</code> 的评论，但是后来浏览了众多博客之后，发现使用 <code>Twikoo</code> 评论的比较多，所以我就萌生了修改评论的方法。而且 <code>Twikoo</code> 评论确实比较好看。</p><p><code>Twikoo</code> 是无后端的网站评论系统，基于腾讯云开发，可以查看其 <a href="https://twikoo.js.org/quick-start.html#%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96">官方文档</a>。</p><h1 id="部署-Twikoo-评论"><a href="#部署-Twikoo-评论" class="headerlink" title="部署 Twikoo 评论"></a>部署 Twikoo 评论</h1><p>我们可以使用免费的 <code>Vercel</code> 进行部署 <code>Twikoo</code> 评论，否则就要使用服务器去部署了。</p><p>官方文档：<a href="https://twikoo.js.org/backend.html#vercel-%E9%83%A8%E7%BD%B2">Vercel 部署 Twikoo</a></p><a href="https://twikoo.js.org/backend.html#vercel-%E9%83%A8%E7%BD%B2" target="_blank" title="Vercel 部署 Twikoo" referrerPolicy="no-referrer" class="link_card"><div class="link_icon"><img src=" https://twikoo.js.org/twikoo-logo-home.png" class="no-lightbox"></div><div class="link_content"><div class="link_title">Vercel 部署 Twikoo</div></div></a><p>下面来详细的介绍部署过程。</p><h2 id="申请-MongoDB-Atlas-账号"><a href="#申请-MongoDB-Atlas-账号" class="headerlink" title="申请 MongoDB Atlas 账号"></a>申请 MongoDB Atlas 账号</h2><p>MongoDB Atlas 是 MongoDB Inc 提供的 MongoDB 数据库托管服务。免费账户可以永久使用 500 MiB 的数据库，足够存储 Twikoo 评论使用。</p><p>首先进入 <a href="https://www.mongodb.com/cloud/atlas/register">MongoDB Atlas 注册界面</a> 进行用户注册，这里我选择使用我的 Google 账号进行登录。</p><p>然后就可以进入一个介绍页面了，你可以选择跳过，也可以按照自己的需求填写。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250827214224054.png" alt="image-20250827214223954" style="zoom:50%;" /><p>接下来我们选择免费的 MongoDB，这里我选择 HK，然后点击 <code>Create Deployment</code> 即可。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250827214552122.png" alt="image-20250827214552014" style="zoom:50%;" /><p>然后我们需要创建数据库用户，并指定密码</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250827214851215.png" alt="image-20250827214851113" style="zoom:50%;" /><p>创建完用户以后，就可以 close 了。接下来在 Network Access 页面点击 Add IP Address 添加网络白名单。因为 Vercel 的出口地址不固定，所以我们这里 Access List Entry 输入 <code>0.0.0.0/0</code>（允许所有 IP 地址的连接）。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250827215202580.png" alt="image-20250827215202431" style="zoom:50%;" /><p>接下来我们切换到 Clusters 标签，选择 Connect。</p><p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250827215354496.png" alt="image-20250827215354398"></p><p>接下来选择连接方式为 <code>Driver</code> ，并复制连接信息。</p><p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250827215620020.png" alt="image-20250827215619900"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mongodb+srv://bczhang:&lt;db_password&gt;@myblog.yd61ctz.mongodb.net/?retryWrites=<span class="literal">true</span>&amp;w=majority&amp;appName=myblog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改为</span></span><br><span class="line"></span><br><span class="line">mongodb+srv://bczhang:你刚刚设置的数据库密码@myblog.yd61ctz.mongodb.net/?retryWrites=<span class="literal">true</span>&amp;w=majority&amp;appName=myblog</span><br></pre></td></tr></table></figure><h2 id="Vercel-部署-Twikoo"><a href="#Vercel-部署-Twikoo" class="headerlink" title="Vercel 部署 Twikoo"></a>Vercel 部署 Twikoo</h2><p>直接点击链接进行部署：<a href="https://vercel.com/new/clone?repository-url=https://github.com/twikoojs/twikoo/tree/main/src/server/vercel-min">New Project-Vercel</a> ，需要进行登录，我这里选择 Github 登录。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250827220505017.png" alt="image-20250827220504933" style="zoom:67%;" /><p>接下来等待 Vercel 部署即可，时间可能会比较久。</p><p>部署完成后按照下图步骤依次执行：</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250827221132455.png" alt="image-20250827221132319" style="zoom:67%;" /><p>接下来进入 <code>Deployment Protection</code> ，设置 <code>Vercel Authentication</code> 为 Disabled，并 Save 保存。</p><p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250827221354683.png" alt="image-20250827221354578"></p><p>接下来按照下图进行：</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250827221520761.png" alt="image-20250827221520622" style="zoom:67%;" /><p>弹出的窗口中继续点击 <code>Redeploy</code> 进行重新部署，等待完成即可。</p><img src = "https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250827221615202.png" style="zoom:67%;"  alt="20250827221615202.png"/><p>部署成功后会显示 “云函数运行正常 …”，然后复制 Domains 下的一个链接，作为 Butterfly 集成 Twikoo 的 <code>envId</code> 。</p><p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250827222114826.png" alt="image-20250827222114724"></p><h2 id="Vercel-绑定域名-可选"><a href="#Vercel-绑定域名-可选" class="headerlink" title="Vercel 绑定域名 (可选)"></a>Vercel 绑定域名 (可选)</h2><p>由于 <code>vercel.app</code> 域名已经被 DNS 污染，那么国内网络应该都是无法进行访问的，所以我们需要绑定自己的域名来转发 Vercel DNS Server 地址。如果你不想这样做，那么访问评论就只能通过 “魔法” 了。</p><p>1、找到 Vercel 中部署的 Twikoo 项目，点击 <code>Settings</code> 选项卡，跳转页面后点击左侧的 <code>Domains</code> ，输入你自己定义的域名。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250828140254540.png" alt="image-20250828140254351" style="zoom:50%;" /><p>2、输入自己的域名即可，这里建议单独买一个域名，避免后续造成 CNAME 指向网址，A 指向 IP 造成的矛盾。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250828151448063.png" alt="image-20250828151447852" style="zoom:50%;" /><p>3、接下来会出现配置问题，根据指引去添加域名解析即可。有一个报错就添加一个，有两个就添加两个，这里我是两个。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250828151634194.png" alt="image-20250828151634053" style="zoom:50%;" /><p>4、根据提示进行解析即可，没什么特别的，我是用的是腾讯云买的域名。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250828151848632.png" alt="image-20250828151848501" style="zoom:50%;" /><p>5、回到 Vercel 界面，<code>Refresh</code> 刷新，看看域名是否解析成功 (需要等待一段时间)。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250828152328231.png" alt="image-20250828152328106" style="zoom:50%;" /><p>6、此时如果在浏览器中输入 <code>https://aiqian.online</code> 显示如下的内容就代表域名解析成功。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Twikoo 云函数运行正常，请参考 https://twikoo.js.org/frontend.html 完成前端的配置&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.6.44&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>7、注意注意注意，第五步的图片是错误的，我们需要打开 <code>Edit</code> 使其禁止重定向，不然会出现跨域问题！！！</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250828155349744.png" alt="image-20250828155349586" style="zoom:67%;" /><h1 id="Twikoo-接入-Butterfly"><a href="#Twikoo-接入-Butterfly" class="headerlink" title="Twikoo 接入 Butterfly"></a>Twikoo 接入 Butterfly</h1><p>回到博客中 Butterfly 主题的配置文件 <code>_config.butterfly.yml</code> ，修改如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">Twikoo</span> <span class="comment"># 修改评论模块</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Twikoo</span></span><br><span class="line"><span class="attr">twikoo:</span></span><br><span class="line">  <span class="attr">envId:</span> <span class="string">https://xxxxxxxxxxx.vercel.app</span> <span class="comment"># 粘贴复制的内容，前面需要加 https://</span></span><br><span class="line">  <span class="attr">region:</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span> <span class="comment"># 是否展示文章阅读数</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure><blockquote><p>如果绑定了域名，可以将 <code>envId</code> 填写为 <code>https://aiqian.online</code> 。</p></blockquote><p>随后使用 <code>hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server</code> 命令即可本地预览是否配置 Twikoo 评论成功。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250828093308711.png" alt="image-20250828093308530" style="zoom:67%;" /><p>然后使用命令 <code>hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</code> 即可托管博客到 Github。</p><h1 id="Twikoo-评论模块美化"><a href="#Twikoo-评论模块美化" class="headerlink" title="Twikoo 评论模块美化"></a>Twikoo 评论模块美化</h1><h2 id="表情包放大效果"><a href="#表情包放大效果" class="headerlink" title="表情包放大效果"></a>表情包放大效果</h2><p>1、粘贴以下内容到自定义的 js 文件即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果当前页有评论就执行函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;post-comment&#x27;</span>)) <span class="title function_">owoBig</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表情放大</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">owoBig</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="number">1</span>, <span class="comment">// 设置节流阀</span></span><br><span class="line">        owo_time = <span class="string">&#x27;&#x27;</span>, <span class="comment">// 设置计时器</span></span><br><span class="line">        m = <span class="number">3</span>; <span class="comment">// 设置放大倍数</span></span><br><span class="line">    <span class="comment">// 创建盒子</span></span><br><span class="line">    <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>),</span><br><span class="line">        body = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>);</span><br><span class="line">    <span class="comment">// 设置ID</span></span><br><span class="line">    div.<span class="property">id</span> = <span class="string">&#x27;owo-big&#x27;</span>;</span><br><span class="line">    <span class="comment">// 插入盒子</span></span><br><span class="line">    body.<span class="title function_">appendChild</span>(div)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造observer</span></span><br><span class="line">    <span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function"><span class="params">mutations</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; mutations.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> dom = mutations[i].<span class="property">addedNodes</span>,</span><br><span class="line">                owo_body = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (dom.<span class="property">length</span> == <span class="number">2</span> &amp;&amp; dom[<span class="number">1</span>].<span class="property">className</span> == <span class="string">&#x27;OwO-body&#x27;</span>) owo_body = dom[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 如果需要在评论内容中启用此功能请解除下面的注释</span></span><br><span class="line">            <span class="comment">// else if (dom.length == 1 &amp;&amp; dom[0].className == &#x27;tk-comment&#x27;) owo_body = dom[0];</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 禁用右键</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span> &lt;= <span class="number">768</span>) owo_body.<span class="title function_">addEventListener</span>(<span class="string">&#x27;contextmenu&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> e.<span class="title function_">preventDefault</span>());</span><br><span class="line">            <span class="comment">// 鼠标移入</span></span><br><span class="line">            owo_body.<span class="property">onmouseover</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 检查父元素的 className 是否包含 &#x27;OwO-packages&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (e.<span class="property">target</span>.<span class="property">parentElement</span>.<span class="property">parentElement</span>.<span class="property">parentElement</span> &amp;&amp; e.<span class="property">target</span>.<span class="property">parentElement</span>.<span class="property">parentElement</span>.<span class="property">parentElement</span>.<span class="property">className</span>.<span class="title function_">includes</span>(<span class="string">&#x27;OwO-packages&#x27;</span>)) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span> (flag &amp;&amp; e.<span class="property">target</span>.<span class="property">tagName</span> == <span class="string">&#x27;IMG&#x27;</span>) &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// 移入300毫秒后显示盒子</span></span><br><span class="line">                    owo_time = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> height = e.<span class="property">target</span>.<span class="property">clientHeight</span> * m, <span class="comment">// 盒子高</span></span><br><span class="line">                            width = e.<span class="property">target</span>.<span class="property">clientWidth</span> * m, <span class="comment">// 盒子宽</span></span><br><span class="line">                            left = (e.<span class="property">x</span> - e.<span class="property">offsetX</span>) - (width - e.<span class="property">target</span>.<span class="property">clientWidth</span>) / <span class="number">2</span>, <span class="comment">// 盒子与屏幕左边距离</span></span><br><span class="line">                            top = e.<span class="property">y</span> - e.<span class="property">offsetY</span>; <span class="comment">// 盒子与屏幕顶部距离</span></span><br><span class="line"> <span class="comment">// 右边缘检测, 防止超出屏幕</span></span><br><span class="line">                        <span class="keyword">if</span> ((left + width) &gt; body.<span class="property">clientWidth</span>) left -= ((left + width) - body.<span class="property">clientWidth</span> + <span class="number">10</span>);</span><br><span class="line">                        <span class="keyword">if</span> (left &lt; <span class="number">0</span>) left = <span class="number">10</span>; <span class="comment">// 左边缘检测, 防止超出屏幕</span></span><br><span class="line">                        <span class="comment">// 设置盒子样式</span></span><br><span class="line">                        div.<span class="property">style</span>.<span class="property">cssText</span> = <span class="string">`display:flex; height:<span class="subst">$&#123;height&#125;</span>px; width:<span class="subst">$&#123;width&#125;</span>px; left:<span class="subst">$&#123;left&#125;</span>px; top:<span class="subst">$&#123;top&#125;</span>px;`</span>;</span><br><span class="line">                        <span class="comment">// 在盒子中插入图片</span></span><br><span class="line">                        div.<span class="property">innerHTML</span> = <span class="string">`&lt;img src=&quot;<span class="subst">$&#123;e.target.src&#125;</span>&quot;&gt;`</span></span><br><span class="line">                    &#125;, <span class="number">300</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 鼠标移出隐藏盒子</span></span><br><span class="line">            owo_body.<span class="property">onmouseout</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                div.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>, flag = <span class="number">1</span>, <span class="built_in">clearTimeout</span>(owo_time);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;post-comment&#x27;</span>), &#123;<span class="attr">subtree</span>: <span class="literal">true</span>, <span class="attr">childList</span>: <span class="literal">true</span>&#125;) <span class="comment">// 监听的元素和配置项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、将以下内容粘贴到自定义的 CSS 文件即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#owo-big</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> <span class="number">#aaa</span> solid;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">9999</span>;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>, -<span class="number">105%</span>);</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">animation</span>: owoIn <span class="number">0.3s</span> <span class="built_in">cubic-bezier</span>(<span class="number">0.42</span>, <span class="number">0</span>, <span class="number">0.3</span>, <span class="number">1.11</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[data-theme=dark]</span> <span class="selector-id">#owo-big</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#4a4a4a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#owo-big</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> owoIn &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>, -<span class="number">95%</span>);</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">100%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">0</span>, -<span class="number">105%</span>);</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、效果展示</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250828101805440.png" alt="image-20250828101805202" style="zoom:67%;" /><h2 id="自定义表情包"><a href="#自定义表情包" class="headerlink" title="自定义表情包"></a>自定义表情包</h2><p>1、点击评论区右下角的 <code>齿轮</code> 图标 (如上图)，设置一个密码，进入管理界面。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250828101956335.png" alt="image-20250828101956208" style="zoom:67%;" /><p>2、进入 Twikoo 管理面板后，依次找到：配置管理、插件。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250828102052453.png" alt="image-20250828102052341" style="zoom:67%;" /><p>3、最后找到 <code>EMOTION_CDN</code> ，填入 <code>https://cdn.cbd.int/daliyuer-static@latest/bq/twikoo.json</code> ，使用大佬制作好的表情包。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250828102232618.png" alt="image-20250828102232494" style="zoom:50%;" /><p>4、最后划到页面最下方，点击保存即可。</p>]]></content>
      
      
      <categories>
          
          <category> Butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 三大日志与两阶段提交</title>
      <link href="/2025/08/26/MySQL/MySQL%20%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/"/>
      <url>/2025/08/26/MySQL/MySQL%20%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MySQL 的三大日志：undo log、redo log、binlog</p><h1 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h1><h2 id="undo-log-保证事务的原子性"><a href="#undo-log-保证事务的原子性" class="headerlink" title="undo log 保证事务的原子性"></a>undo log 保证事务的原子性</h2><p>执行一组 SQL 语句，要么全部成功，要么全部失败，失败了需要把前面执行成功的 SQL 语句进行回滚，这就是 MySQL 事务的原子性。此时就出现了一个问题：数据都进行修改了，是怎么进行回滚的？</p><p>这就需要 undo log 了。undo log 中记录了数据的不同版本，每修改一次就记录一次对应的版本，随后把数据不同的版本通过一个回滚指针串联起来，这就是 undo log 版本链。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250825153432795.png" alt="image-20250825153432631" style="zoom:67%;" /><p>也就是说，只要事务执行过程中出现了数据的修改，MySQL 就会把旧数据记录到 undo log 日志当中。如果事务正常提交，那就什么事没有；如果事务执行出现了异常，那就会读取 undo log 日志找到旧数据的版本进行回滚，<strong>这就是 undo log 保证事务原子性的原理</strong>。</p><h2 id="undo-log-与-MVCC"><a href="#undo-log-与-MVCC" class="headerlink" title="undo log 与 MVCC"></a>undo log 与 MVCC</h2><p><strong>undo log 的第二个作用就是配合 readview 与表中的隐藏字段实现 MVCC。</strong></p><p>简单来说，MVCC 执行普通的 select 语句时，会去对比事务的 id 和 readview 来判断数据版本是否对当前的事务可见。如果不可见，就继续沿着 undo log 版本链去查找当前事务可见的数据版本。</p><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><h2 id="buffer-pool"><a href="#buffer-pool" class="headerlink" title="buffer pool"></a>buffer pool</h2><p>MySQL 中的数据是存储在磁盘当中的，但是每次都从磁盘读取数据就会很慢，因此 MySQL 设计了一个 buffer pool 缓冲池。MySQL 存数据是以页为单位的，一页的大小是 16 KB，每查询一次数据就会从磁盘把这一页的数据都加载出来，然后放到 buffer pool 当中。</p><h2 id="程序的空间局部性"><a href="#程序的空间局部性" class="headerlink" title="程序的空间局部性"></a>程序的空间局部性</h2><p>为什么每次查询一条数据都会把一整页加载到 buffer pool 当中，而不是单独的这一条数据？</p><p>这就涉及到了程序的空间局部性原理：一个内存地址被访问，这就意味着它附近的内存地址也有可能会被访问，这就好比你刷抖音，当前的视频被访问，那么下一个视频会有极其大的概率也会被访问，这就是一种翻页。</p><p>而 MySQL 一次性把一整页的数据都加载到 buffer pool 当中，那么对于连续存储的数据来说，命中率就会非常高，比如数组。后续再次查找数据的时候就会优先从 buffer pool 中去读取，不存在了再去磁盘当中读取。相应地，写入数据也是先写入 buffer pool，但是不会直接刷入数据到磁盘，而是先将修改的页标记为脏页，再由后台线程在某个时间把脏页刷入到磁盘。</p><h2 id="redo-log-的必要性"><a href="#redo-log-的必要性" class="headerlink" title="redo log 的必要性"></a>redo log 的必要性</h2><p>如果在 buffer pool 还没有刷入脏页到磁盘中的时候，MySQL 宕机了，不就出现了数据丢失，该怎么避免？</p><p>此时 redo log 的作用就体现出来了。MySQL 会把某个磁盘页修改的数据记录在 redo log 中，事务提交之后就刷盘 redo log。如果 buffer pool 中的数据未刷盘就宕机了，那么就可以读取 redo log 来恢复数据，<strong>这也就是 redo log 能够保证事务持久性的原因</strong>，能够让 MySQL 做到崩溃后的数据恢复。</p><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p><strong>为什么不直接刷盘 buffer pool，而是刷盘 redo log？</strong></p><p>因为 buffer pool 刷盘是随机 IO，刷盘的时候需要找到某个磁盘页，然后修改，然后再去找另外一个磁盘页，再修改。本来磁盘操作就慢，随机 IO 的话就更慢了。</p><p>但是 redo log 只记录在哪个磁盘位置做了怎样的修改，刷盘时只需要往 redo log 日志文件后追加就行了，这就是顺序 IO，不需要找这个磁盘页找那个磁盘页，磁盘的磁头只需要沿着一个方向移动就行了。</p><p>这也就是为什么 redo log 里面要记录数据页的物理修改，而不是直接记录数据。所以只要 redo log 一刷盘，即便 MySQL 崩溃了也能够恢复数据，事务的持久性也能够得到保证。</p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p><strong>如果 redo log 还没来得及刷盘，MySQL 就宕机了，会丢失数据吗？</strong></p><p>我们需要先了解一下 redo log 的刷盘机制，再来解答这个问题。</p><p>redo log 其实也不是直接写入磁盘的，redo log 有自己的缓存，叫 redo log buffer。redo log 会先写入到 redo log buffer，然后统一把 redo log buffer 中的数据刷入到磁盘中。</p><p>MySQL 中有一个参数 <code>innodb_flush_log_at_trx_commit</code> ，可以控制 redo log 的刷盘时间。</p><p>如果值为 0，事务提交时会把 redo log 的数据放入 redo log buffer，并不会刷入磁盘。</p><p>如果值为 1，事务提交时会把 redo log 的数据刷入磁盘，刷盘完成后才会告诉客户端事务执行成功了。这也就保证了事务只要完成，即便 MySQL 崩溃了数据也不会丢失。所以一般情况下，把这个参数设置为 1，那事务提交 redo log 就能刷盘，事务的持久性也能够得到保证，1 也是这个参数的默认值。</p><p>如果值为 2，事务提交时会把 redo log 的数据写入操作系统的文件缓存中，也就是 page cache。操作系统本身对文件也是有缓存的，数据写入 page cache        后，操作系统就会在某个时间把数据写入磁盘，只要操作系统不崩溃，那就能保证持久性。</p><h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><p><strong>现在需要做数据库的备份用于备份恢复，或者需要搭建主从架构，完成主从复制，那么 redo log 能胜任这些工作吗？</strong></p><p>这是不行的。redo log 是一种环形日志，其空间大小是固定的。全部写满了就会从头再开始写，边写边覆盖前面的数据。因此它只能记录事务提交后没有被刷盘的数据，已经刷盘的会从 redo log 中擦除掉。</p><p>redo log 是事务级的数据记录，不是数据库级的。它只能做一些因为断电或者数据库故障导致 buffer pool 中的数据未刷盘的数据恢复，不能做数据库全量数据恢复。</p><p>如果需要进行数据库的数据恢复，则需要使用到 binlog 日志文件。</p><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><p>只要对 MySQL 做了变更，无论是数据还是表结构的增删改，都会记录一个二进制日志 binlog。</p><p>redo log 是物理日志，记录的内容是 “在某个数据页上做了什么修改”。而 binlog 是逻辑日志，记录的内容就类似于 SQL 语句本身，所以 binlog 非常适合做备份恢复和主从同步。</p><blockquote><p>删库跑路时也最好把 binlog 一起顺手删了，这是非常可刑的。</p></blockquote><p>相比于 redo log，binlog 也有对应的 binlog cache。事务执行过程中，会先把 binlog 日志写到 binlog cache；事务提交的时候，就会把 binlog cache 刷到磁盘中。</p><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h1><p><strong>事务提交后，redo log 和 binlog 都要刷盘，但是如果一个刷盘成功了，一个失败了，两份日志就不一致了，这种情况该怎么办？</strong></p><p>为了解决两份日志之间的一致性问题，MySQL 将 redo log 的写入拆成了两个步骤：<code>prepare</code> 和 <code>commit</code> ，这就是两阶段提交。</p><p>整个执行流程如下：</p><ul><li>开启事务</li><li>更新数据 </li><li>写入 redo log，此时 redo log 是 <code>prepare</code> 阶段</li><li>提交事务，写入 binlog，并将 redolog 设置为 <code>commit</code> 阶段</li></ul><p><strong>1、如果写入 redo log 时出现了异常，该怎么解决？</strong></p><p>此时 redo 处于 <code>prepare</code> 阶段，binlog 中没有数据，直接回滚事务即可。</p><p><strong>2、 如果写入 binlog 时出现了异常，该怎么解决？</strong></p><p>此时 binlog 已经写入，但 redo 还没有进入 <code>commit</code> 阶段，此时就需要对比 redo log <code>prepare</code> 阶段的数据与 binlog 是否一致，一致就提交事务，不一致就回滚事务。</p><p><strong>3、怎么比较 redo log 与 binlog 的数据是否一致？</strong></p><p>redo log 与 binlog 中存在一个共同的字段 <code>XID</code> 。因此崩溃恢复的时候，扫描 redo log，如果发现有 <code>prepare</code> 的 redolog，则利用它的 <code>XID</code> 去 binlog 查询，如果找到对应的数据，则说明数据都保存了，事务可以提交，反之事务回滚。</p><p>由此看来，两阶段提交最终还是要看 binlog 日志。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四大服务限流算法</title>
      <link href="/2025/08/26/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%9B%9B%E5%A4%A7%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
      <url>/2025/08/26/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%9B%9B%E5%A4%A7%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="限流是什么？"><a href="#限流是什么？" class="headerlink" title="限流是什么？"></a>限流是什么？</h1><p>限流，也称流量控制。是指系统在面临高并发，或者 <strong>大流量请求</strong> 的情况下，<strong>限制新的请求对系统的访问</strong>，从而 <strong>保证系统的稳定性</strong>。限流会导致部分用户请求处理不及时或者被拒，这就影响了用户体验。所以一般需要在系统稳定和用户体验之间 <strong>平衡</strong> 一下。</p><p>这里列举一个生活化的例子：</p><p>一些热门的旅游景区，一般会对每日的旅游参观人数有限制。每天只会卖出固定数目的门票，比如 5000 张。假设在五一、国庆假期，你去晚了，可能当天的票就已经卖完了，就无法进去游玩了。即使你进去了，排队也能排到你怀疑人生。</p><h1 id="为什么需要限流？"><a href="#为什么需要限流？" class="headerlink" title="为什么需要限流？"></a>为什么需要限流？</h1><p>限流 (Rate Limiting) 是一种重要的系统保护机制，其主要目的是 <strong>控制进入系统或服务的请求流量，以防止系统过载、保证服务稳定性和可用性</strong>。</p><p>之所以要使用限流，是因为其具有几大优势：</p><ul><li><strong>防止系统过载</strong>：任何系统 (服务器、数据库、网络带宽等) 的处理能力都是有限的。当瞬时流量 (如秒杀、热点事件、恶意攻击) 远超系统承载能力时，可能导致CPU、内存、I&#x2F;O 等资源耗尽。</li><li><strong>保证服务质量</strong>：通过限制总请求数或特定用户的请求频率，可以避免少数 “坏邻居” (如恶意爬虫、配置错误的客户端) 占用过多资源，从而保证大多数用户的良好体验和系统响应延迟。</li><li><strong>抵御DDoS&#x2F;DoS攻击</strong>：分布式拒绝服务 (DDoS) 或拒绝服务 (DoS) 攻击会通过海量请求淹没目标系统。限流是第一道防线，可以识别并阻止异常的流量洪峰。</li><li><strong>防止暴力破解</strong>：对登录、支付、验证码等敏感接口进行限流，可以有效防止攻击者通过暴力尝试 (如密码爆破) 来窃取信息或进行欺诈。</li><li><strong>成本控制</strong>：在云环境中，资源使用通常与成本挂钩 (如按调用次数计费的 API、按流量计费的带宽)。限流可以防止因异常流量导致的成本意外飙升。</li><li><strong>应对突发流量</strong>：互联网业务常有流量高峰 (如节假日促销、新品发布) 。合理的限流策略 (结合弹性扩容) 可以在系统能力范围内优雅地处理这些峰值，而不是直接崩溃。</li></ul><h1 id="四大服务限流算法"><a href="#四大服务限流算法" class="headerlink" title="四大服务限流算法"></a>四大服务限流算法</h1><p>常见的限流算法主要有四种：</p><ul><li>固定窗口算法</li><li>滑动窗口算法</li><li>漏桶算法</li><li>令牌桶算法</li></ul><h2 id="固定窗口算法"><a href="#固定窗口算法" class="headerlink" title="固定窗口算法"></a>固定窗口算法</h2><p>固定窗口其实就是时间窗口，其原理是 <strong>将时间划分为固定大小的窗口</strong>，在每个窗口内限制请求的数量或速率，即固定窗口算法规定了系统单位时间处理的请求数量。</p><p>假如我们规定系统中某个接口 1 秒钟只能被访问 3 次的话，使用固定窗口算法的实现思路如下：</p><ul><li>将时间划分固定大小窗口，这里是 1s 一个窗口。</li><li>给定一个变量 <code>counter</code> 来记录当前接口处理的请求数量，初始值为 0，代表接口当前 1s 内还未处理请求。</li><li>1s 之内每处理一个请求之后就将 <code>counter + 1</code> ，当 <code>counter = 3</code> 之后，也就是在 1s 内接口已经被访问 3 次的话，后续的请求就会被全部拒绝。</li><li>等到 1s 结束后，将 <code>counter</code> 重置为 0，重新开始计数。</li></ul><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250826151816752.png" alt="image-20250826151816523" style="zoom:75%;" /><p>固定窗口算法的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 固定窗口算法限流器</span></span><br><span class="line"><span class="comment"> * 规定在 1 秒内最多接受 3 个请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedWindowRateLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 定义常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WINDOW_SIZE_MS</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">// 窗口大小: 1秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_REQUESTS</span> <span class="operator">=</span> <span class="number">3</span>;       <span class="comment">// 每个窗口内允许的最大请求数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 存储状态的映射</span></span><br><span class="line"><span class="comment">     * Key: 限流的标识符: userId, 设备 ip 等</span></span><br><span class="line"><span class="comment">     * Value: 该 Key 在当前窗口内的请求数</span></span><br><span class="line"><span class="comment">     * 使用 ConcurrentHashMap 保证线程安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, WindowCounter&gt; counterMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 核心方法: 判断指定 key 的请求是否被允许</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 唯一标识符, 如: &quot;user:123&quot;, &quot;ip:192.168.1.1&quot;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 如果请求被允许, false 如果被拒绝(限流)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAllowed</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || key.trim().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Key cannot be null or empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTimeMs</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 获取当前时间戳(毫秒)</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentWindowStart</span> <span class="operator">=</span> getWindowStart(currentTimeMs); <span class="comment">// 计算当前窗口的开始时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 使用 compute 方法原子地处理状态更新</span></span><br><span class="line">        <span class="comment">// compute 方法会根据 key 的存在与否, 调用不同的函数</span></span><br><span class="line">        <span class="keyword">return</span> counterMap.compute(key, (k, counter) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 情况1: 这个key是第一次出现, 或者其记录的窗口已过期</span></span><br><span class="line">            <span class="keyword">if</span> (counter == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建新计数器, 计数为1, 窗口为当前窗口</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowCounter</span>(<span class="number">1</span>, currentWindowStart);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 情况2: key存在, 检查是否还在同一个窗口内</span></span><br><span class="line">            <span class="keyword">if</span> (counter.windowStart == currentWindowStart) &#123;</span><br><span class="line">                <span class="comment">// 在同一个窗口内</span></span><br><span class="line">                <span class="keyword">if</span> (counter.count &lt; MAX_REQUESTS) &#123;</span><br><span class="line">                    <span class="comment">// 计数未满, 允许请求, 计数 + 1</span></span><br><span class="line">                    counter.count++;</span><br><span class="line">                    <span class="keyword">return</span> counter; <span class="comment">// 返回更新后的计数器</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 计数已满, 拒绝请求</span></span><br><span class="line">                    <span class="comment">// 注意: 这里仍然返回counter, 但 count 不增加, 表示拒绝</span></span><br><span class="line">                    <span class="comment">// 调用者根据返回值判断是否允许</span></span><br><span class="line">                    <span class="keyword">return</span> counter;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 情况3: 已经进入新的窗口, 重置计数器</span></span><br><span class="line">                <span class="comment">// 从新窗口开始计算, 计数为 1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowCounter</span>(<span class="number">1</span>, currentWindowStart);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).count &lt;= MAX_REQUESTS; <span class="comment">// compute 返回的是更新后的 WindowCounter</span></span><br><span class="line">                                 <span class="comment">// 我们判断其 count 是否 &lt;= MAX_REQUESTS 来决定是否允许</span></span><br><span class="line">                                 <span class="comment">// 注意: 即使 count &gt; MAX_REQUESTS(在窗口内已满), compute 也会返回该对象</span></span><br><span class="line">                                 <span class="comment">// 所以这里需要比较.更精确的做法是让 compute 返回一个状态对象.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 5. 辅助方法: 根据当前时间戳计算所属窗口的开始时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timestamp 当前时间戳(毫秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 窗口开始时间戳(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getWindowStart</span><span class="params">(<span class="type">long</span> timestamp)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (timestamp / WINDOW_SIZE_MS) * WINDOW_SIZE_MS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 6. 内部类: 封装窗口计数器状态</span></span><br><span class="line"><span class="comment">     * 包含当前窗口的开始时间和该窗口内的请求数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WindowCounter</span> &#123;</span><br><span class="line">        <span class="type">int</span> count;           <span class="comment">// 当前窗口内的请求数</span></span><br><span class="line">        <span class="type">long</span> windowStart;    <span class="comment">// 当前窗口的开始时间戳(毫秒)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WindowCounter</span><span class="params">(<span class="type">int</span> count, <span class="type">long</span> windowStart)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.count = count;</span><br><span class="line">            <span class="built_in">this</span>.windowStart = windowStart;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定key的当前状态(用于监控或调试)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 限流标识符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> WindowCounter 状态, 如果不存在则返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> WindowCounter <span class="title function_">getStatus</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counterMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除指定key的状态(通常用于测试或手动重置)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 限流标识符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        counterMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种算法有一个很明显的 <strong>临界问题</strong>：</p><ul><li>假如在第 5、6 秒，请求数量都为 3，没有超过阈值，全部放行</li><li>但是，如果第 5 秒的三次请求都是在 4.5 ～ 5 秒之间进来；第 6 秒的请求是在 5 ～ 5.5 之间进来。那么从第 4.5 ～ 5.5 之间就有 6 次请求！也就是说每秒的 QPS 达到了 6，远超阈值。</li></ul><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250826153902857.png" alt="image-20250826153902720" style="zoom:80%;" /><p>在当前场景下，这 6 个请求在 1s 内是没办法被处理的，系统直接就被瞬时的大量请求给击垮了。</p><p>这就是固定窗口算法的问题，它只能统计当前某 1 个时间窗的请求数量是否到达阈值，无法结合前后的时间窗的数据做综合统计。因此，我们就需要 <strong>滑动窗口算法</strong> 来解决。</p><h2 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h2><p>滑动窗口算法算的上是固定窗口算法的升级版，限流的颗粒度更小。滑动窗口算法相比于固定窗口算法的优化在于：<strong>它将单位时间周期分为 n 个小周期，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期。</strong> 。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250826155350080.png" alt="image-20250826155349947" style="zoom:80%;" /><p>假设单位时间还是 1s，滑动窗口算法把它划分为 5 个小周期，也就是滑动窗口 (单位时间) 被划分为5个小格子。每格表示 0.2s。每过 0.2s，时间窗口就会往右滑动一格。然后每个小周期都有自己独立的计数器，如果请求是 0.83s 到达的，0.8 ~ 1.0s 对应的计数器就会加 1。</p><p>假设我们 1s 内的限流阀值是 5 个请求，0.8 ~ 1.0s 内，比如 0.9s 的时候来了 5 个请求，落在天蓝色格子里。时间过了 1.0s 这个点之后，又来 5 个请求，落在紫色格子里。此时如果 <strong>是固定窗口算法，是不会被限流的</strong>，但是 <strong>滑动窗口的话，每过一个小周期，它会右移一个小格</strong>。过了 1.0s 这个点后，会右移一小格，当前的单位时间段是 0.2 ~1.2s，这个区域的请求已经超过限定的 5 了，已经触发了限流。实际上，紫色格子的请求就都被拒绝了。</p><blockquote><p>当滑动窗口的格子周期划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。</p></blockquote><p>滑动窗口算法的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分桶滑动窗口算法限流器</span></span><br><span class="line"><span class="comment"> * 单位时间: 1秒, 划分为 5 个桶, 每个桶 0.2 秒</span></span><br><span class="line"><span class="comment"> * 1 秒内最多允许 5 个请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindowBucketRateLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 定义常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">UNIT_TIME_MS</span> <span class="operator">=</span> <span class="number">1000</span>;       <span class="comment">// 单位时间: 1秒(毫秒)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM_BUCKETS</span> <span class="operator">=</span> <span class="number">5</span>;            <span class="comment">// 桶的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BUCKET_SIZE_MS</span> <span class="operator">=</span> UNIT_TIME_MS / NUM_BUCKETS; <span class="comment">// 每个桶的大小: 200 毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_REQUESTS_PER_UNIT_TIME</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 单位时间内最大请求数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 存储状态的映射</span></span><br><span class="line"><span class="comment">     * Key: 限流的标识符, 如 userId, IP</span></span><br><span class="line"><span class="comment">     * Value: 一个循环数组(或环形缓冲区), 存储最近 NUM_BUCKETS 个桶的计数</span></span><br><span class="line"><span class="comment">     * 数组的每个元素是一个包含时间戳和计数的结构</span></span><br><span class="line"><span class="comment">     * 使用 ConcurrentHashMap 保证线程安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Bucket[]&gt; bucketMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 核心方法：判断指定 key 的请求是否被允许</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 唯一标识符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 如果允许, false 如果拒绝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAllowed</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || key.trim().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Key cannot be null or empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTimeMs</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentBucketIndex</span> <span class="operator">=</span> getCurrentBucketIndex(currentTimeMs); <span class="comment">// 计算当前属于哪个桶索引(0-4)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取或初始化该 key 的桶数组</span></span><br><span class="line">        Bucket[] buckets = bucketMap.computeIfAbsent(key, k -&gt; createEmptyBuckets());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 计算当前滑动窗口覆盖的范围: [currentTimeMs - UNIT_TIME_MS, currentTimeMs]</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">windowStartTimeMs</span> <span class="operator">=</span> currentTimeMs - UNIT_TIME_MS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 遍历所有桶, 累加在滑动窗口内的请求数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalRequestsInWindow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NUM_BUCKETS; i++) &#123;</span><br><span class="line">            <span class="type">Bucket</span> <span class="variable">bucket</span> <span class="operator">=</span> buckets[i];</span><br><span class="line">            <span class="comment">// 检查这个桶是否在当前滑动窗口内 (即桶的时间戳 &gt;= 窗口开始时间)</span></span><br><span class="line">            <span class="keyword">if</span> (bucket.timestamp &gt;= windowStartTimeMs) &#123;</span><br><span class="line">                totalRequestsInWindow += bucket.count.get();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意: 旧桶(timestamp &lt; windowStartTimeMs)的计数被自然排除, 相当于过期</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 检查总请求数是否超过阈值</span></span><br><span class="line">        <span class="keyword">if</span> (totalRequestsInWindow &gt;= MAX_REQUESTS_PER_UNIT_TIME) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 拒绝请求</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8. 请求被允许, 需要更新当前所属的桶</span></span><br><span class="line">        <span class="comment">// 使用原子操作更新当前桶的计数</span></span><br><span class="line">        <span class="type">Bucket</span> <span class="variable">currentBucket</span> <span class="operator">=</span> buckets[(<span class="type">int</span>) currentBucketIndex];</span><br><span class="line">        <span class="comment">// 8.1 检查当前桶的时间戳是否还是当前周期</span></span><br><span class="line">        <span class="keyword">if</span> (currentBucket.timestamp &lt; currentTimeMs) &#123;</span><br><span class="line">            <span class="comment">// 时间已进入新的桶周期, 需要重置这个桶</span></span><br><span class="line">            <span class="comment">// 使用 CAS 或 synchronized 块确保重置的原子性</span></span><br><span class="line">            <span class="keyword">synchronized</span> (currentBucket) &#123; <span class="comment">// 确保重置和设置计数的原子性</span></span><br><span class="line">                <span class="comment">// 再次检查, 防止竞态</span></span><br><span class="line">                <span class="keyword">if</span> (currentBucket.timestamp &lt; currentTimeMs) &#123;</span><br><span class="line">                    currentBucket.timestamp = getBucketStartTime(currentTimeMs); <span class="comment">// 设置为当前桶的开始时间</span></span><br><span class="line">                    currentBucket.count.set(<span class="number">1</span>); <span class="comment">// 重置计数为1(新请求)</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 另一个线程已经更新了, 只需递增</span></span><br><span class="line">                    currentBucket.count.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 桶时间戳正确，直接递增</span></span><br><span class="line">            currentBucket.count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 允许请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 9. 辅助方法: 创建一个初始化的空桶数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Bucket[] 初始化的桶数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Bucket[] createEmptyBuckets() &#123;</span><br><span class="line">        Bucket[] buckets = <span class="keyword">new</span> <span class="title class_">Bucket</span>[NUM_BUCKETS];</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTimeMs</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">baseTime</span> <span class="operator">=</span> getBucketStartTime(currentTimeMs); <span class="comment">// 第一个桶的开始时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NUM_BUCKETS; i++) &#123;</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">Bucket</span>(baseTime + i * BUCKET_SIZE_MS, <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buckets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 10. 辅助方法: 根据当前时间戳计算其所属桶的索引(0 到 NUM_BUCKETS - 1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timestamp 当前时间戳(毫秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 桶索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getCurrentBucketIndex</span><span class="params">(<span class="type">long</span> timestamp)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算时间戳在哪个桶周期内, 然后取模得到索引</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">bucketCycle</span> <span class="operator">=</span> timestamp / BUCKET_SIZE_MS;</span><br><span class="line">        <span class="keyword">return</span> bucketCycle % NUM_BUCKETS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 11. 辅助方法: 根据时间戳计算其所属桶的开始时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timestamp 时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该时间戳所属桶的开始时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getBucketStartTime</span><span class="params">(<span class="type">long</span> timestamp)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (timestamp / BUCKET_SIZE_MS) * BUCKET_SIZE_MS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 12. 内部类: 表示一个时间桶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bucket</span> &#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">long</span> timestamp; <span class="comment">// 该桶代表的时间周期的开始时间戳(毫秒)</span></span><br><span class="line">        AtomicLong count;        <span class="comment">// 该桶内的请求数(使用 AtomicLong 保证递增的原子性)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bucket</span><span class="params">(<span class="type">long</span> timestamp, AtomicLong count)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.timestamp = timestamp;</span><br><span class="line">            <span class="built_in">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 可选, 清理过期状态的方法 ---</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理逻辑(生产环境需要实现)</span></span><br><span class="line"><span class="comment">     * 可以定期扫描 bucketMap, 移除长时间未活动的 key</span></span><br><span class="line"><span class="comment">     * 或者为每个 key 设置 TTL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cleanupStaleKeys</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于固定窗口算法，滑动窗口算法可以应对突然激增的流量，但还是存在限流不够平滑的问题，且实现和理解起来也更复杂。</p><p>例如，我们限制某个接口每分钟只能访问 30 次，假设前 30 秒就有 30 个请求到达的话，那后续 30 秒将无法处理请求，这是不可取的，用户体验极差！</p><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>我们可以把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。</p><p>如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了，和消息队列削峰&#x2F;限流的思想是一样的。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250826162114374.png" alt="image-20250826162114214" style="zoom:67%;" /><p>漏桶算法伪代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 漏桶算法限流器</span></span><br><span class="line"><span class="comment"> * 特点: 以恒定速率处理请求, 平滑突发流量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeakyBucketRateLimiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 定义常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">LEAK_RATE_MS</span> <span class="operator">=</span> <span class="number">200</span>; <span class="comment">// 漏水速率: 每 200ms 漏一滴水(即每秒处理 5 个请求)</span></span><br><span class="line">    <span class="comment">// 可以根据需要调整, 例如 LEAK_RATE_MS=100 表示每秒处理 10 个请求</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUCKET_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 漏桶容量: 最多容纳 10 个请求</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 存储状态的映射</span></span><br><span class="line"><span class="comment">     * Key: 限流的标识符, 如 userId, IP</span></span><br><span class="line"><span class="comment">     * Value: 该 Key 对应的漏桶状态</span></span><br><span class="line"><span class="comment">     * 使用 ConcurrentHashMap 保证线程安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, LeakyBucket&gt; bucketMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 核心方法: 尝试处理一个请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 唯一标识符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 如果请求被接受(放入桶中), false 如果被拒绝(桶满)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || key.trim().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Key cannot be null or empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取或初始化该 key 的漏桶</span></span><br><span class="line">        <span class="type">LeakyBucket</span> <span class="variable">bucket</span> <span class="operator">=</span> bucketMap.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> <span class="title class_">LeakyBucket</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 尝试将请求加入桶中(进水)</span></span><br><span class="line">        <span class="keyword">return</span> bucket.tryAddRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 6. 内部类: 表示一个漏桶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LeakyBucket</span> &#123;</span><br><span class="line">        <span class="comment">// 桶的当前水量(即待处理的请求数)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">waterLevel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上次漏水的时间戳(毫秒)</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">lastLeakTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于同步漏水和加水操作的锁</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 7. 尝试向桶中添加一个请求</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> true 如果成功加入, false 如果桶满被拒绝</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAddRequest</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">currentTimeMs</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 关键: 在尝试加水前, 先让桶漏掉一部分水(模拟恒定速率漏水)</span></span><br><span class="line">            <span class="comment">// 这确保了漏水是持续进行的, 即使没有新请求到来</span></span><br><span class="line">            leakWater(currentTimeMs);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9. 尝试加水(请求)</span></span><br><span class="line">            <span class="comment">// 检查加水后是否超过容量</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">currentLevel</span> <span class="operator">=</span> waterLevel.get();</span><br><span class="line">            <span class="keyword">if</span> (currentLevel &lt; BUCKET_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">// 桶未满, 可以加水</span></span><br><span class="line">                <span class="comment">// 使用 CAS 操作尝试增加水位</span></span><br><span class="line">                <span class="keyword">if</span> (waterLevel.compareAndSet(currentLevel, currentLevel + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 请求被接受</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// CAS 失败, 说明水位被其他线程修改, 可以重试或返回失败</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 桶已满, 拒绝请求</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 10. 核心方法: 根据时间流逝, 让桶漏掉相应的水量</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> currentTimeMs 当前时间戳</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leakWater</span><span class="params">(<span class="type">long</span> currentTimeMs)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取锁, 确保漏水计算的原子性</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 计算距离上次漏水过去了多少时间</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">timeElapsedMs</span> <span class="operator">=</span> currentTimeMs - lastLeakTimestamp;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果时间流逝足够长, 产生了可以漏掉的 &quot;水滴&quot;</span></span><br><span class="line">                <span class="keyword">if</span> (timeElapsedMs &gt;= LEAK_RATE_MS) &#123;</span><br><span class="line">                    <span class="comment">// 计算应该漏掉多少&quot;水滴&quot;</span></span><br><span class="line">                    <span class="comment">// 例如, 过去了 550ms, LEAK_RATE_MS=200, 则应漏掉 550/200 = 2 滴</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">dropsToLeak</span> <span class="operator">=</span> timeElapsedMs / LEAK_RATE_MS;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 计算实际能漏掉的水量(不能超过当前水位)</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">waterToLeak</span> <span class="operator">=</span> Math.min(dropsToLeak, waterLevel.get());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 减少水位</span></span><br><span class="line">                    waterLevel.addAndGet(-waterToLeak);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 更新上次漏水的时间戳</span></span><br><span class="line">                    <span class="comment">// 新的时间戳 = 上次时间戳 + (实际漏掉的水滴数 * 漏水间隔)</span></span><br><span class="line">                    <span class="comment">// 这样可以处理&quot;欠漏&quot;的情况</span></span><br><span class="line">                    lastLeakTimestamp += dropsToLeak * LEAK_RATE_MS;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果时间流逝不足 LEAK_RATE_MS, 则不漏水, 等待下次</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 可选: 获取桶状态 ---</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCurrentWaterLevel</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> waterLevel.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLastLeakTimestamp</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lastLeakTimestamp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 重要: 后台任务 ---</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 11. 后台任务 (生产环境强烈建议)</span></span><br><span class="line"><span class="comment">     * 即使没有新请求到来, 桶也应该持续漏水</span></span><br><span class="line"><span class="comment">     * 可以启动一个定时任务, 定期调用所有桶的 leakWater() 方法</span></span><br><span class="line"><span class="comment">     * 或者, 在 tryAcquire() 中每次调用都执行 leakWater() (如本伪代码所示)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Scheduled</span>(fixedRate = 50) // 每 50ms 检查一次</span></span><br><span class="line"><span class="comment">     * public void backgroundLeak() &#123;</span></span><br><span class="line"><span class="comment">     *     for (LeakyBucket bucket : bucketMap.values()) &#123;</span></span><br><span class="line"><span class="comment">     *         bucket.leakWater(System.currentTimeMillis());</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     *     // 注意: 清理长时间未活动的 key</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果桶流入水 (发请求) 的速率如果一直大于桶流出水 (处理请求) 的速率的话，那么桶会一直是满的，一部分新的请求会被丢弃，导致服务质量下降。且漏桶算法无法应对突然激增的流量，因为只能以固定的速率处理请求，对系统资源利用不够友好。</p><p>所以实际业务场景中，基本不会使用漏桶算法。</p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法也比较简单和漏桶算法算法一样，都是基于桶的。不过现在桶里装的是令牌了，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃 (删除)。我们根据限流大小，按照一定的速率往桶里添加令牌。如果桶装满了，就不能继续往里面继续添加令牌了。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250826163421982.png" alt="image-20250826163421773" style="zoom:67%;" /><p>该算法可以限制平均速率和应对突然激增的流量，也可以动态调整生成令牌的速率。这也是我们最常用的限流算法，因此我们可以使用一些已经封装好的 API 去实现令牌桶限流，这个后续再说。</p><h1 id="针对什么进行限流？"><a href="#针对什么进行限流？" class="headerlink" title="针对什么进行限流？"></a>针对什么进行限流？</h1><p>实际项目中，还需要确定限流对象，也就是针对什么来进行限流。常见的限流对象如下：</p><ul><li>IP：针对 IP 进行限流，适用面较广，简单粗暴。</li><li>业务 ID：挑选唯一的业务 ID 以实现更针对性地限流。例如，基于用户 ID 进行限流。</li><li>个性化：根据用户的属性或行为，进行不同的限流策略。例如，VIP 用户不限流，而普通用户限流。根据系统的运行指标 (如 QPS、并发调用数、系统负载等)，动态调整限流策略。例如，当系统负载较高的时候，控制每秒通过的请求减少。</li></ul><p>针对 IP 进行限流是目前比较常用的一个方案。不过，实际应用中需要注意用户真实 IP 地址的正确获取。常用的真实 IP 获取方法有 X-Forwarded-For 和 TCP Options 字段承载真实源 IP 信息。虽然 X-Forwarded-For 字段可能会被伪造，但因为其实现简单方便，很多项目还是直接用的这种方法。</p><p>除了上面介绍到的限流对象之外，还有一些其他较为复杂的限流对象策略，比如阿里的 Sentinel 还支持 <a href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6#%E5%9F%BA%E4%BA%8E%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">基于调用关系的限流</a> (包括基于调用方限流、基于调用链入口限流、关联流量限流等) 以及更细维度的 <a href="https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81">热点参数限流</a> (实时的统计热点参数并针对热点参数的资源调用进行流量控制)。</p><p>另外，一个项目可以根据具体的业务需求选择多种不同的限流对象搭配使用。</p><h1 id="单机限流"><a href="#单机限流" class="headerlink" title="单机限流"></a>单机限流</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>单机限流针对的是单体架构应用，可以直接使用 Google Guava 自带的限流工具类 <code>RateLimiter</code> 。 <code>RateLimiter</code> 基于令牌桶算法，可以应对突发流量。</p><blockquote><p>Google Guava 地址：<a href="https://github.com/google/guava">https://github.com/google/guava</a></p></blockquote><p>除了最基本的令牌桶算法 (平滑突发限流) 实现之外，Guava 的 <code>RateLimiter</code> 还提供了 <strong>平滑预热限流</strong> 的算法实现。</p><p>平滑突发限流就是按照指定的速率放令牌到桶里，而平滑预热限流会有一段预热时间，预热时间之内，速率会逐渐提升到配置的速率。举例说明就是，假设我规定了 1s 处理 10 个请求，那么平滑突发限流就会按照每 0.1s 的速率来生成一个令牌；如果我指定了预热时间，假设指定了预热时间为 3s，那么前 3s 生成令牌的速率不是固定的，而是逐渐提升到 0.1s 生成一个令牌，预热时间 3s 过后才会维持速率统一。</p><h2 id="简单使用说明"><a href="#简单使用说明" class="headerlink" title="简单使用说明"></a>简单使用说明</h2><p>首先我们需要现在项目中引入 guava 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- guava --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>33.4.8-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>平滑突发限流与平滑预热限流调用的 API 是一样的，只是传入的参数数量不一致而已，下面简单进行说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平滑突发限流, 1s 内生成 10 个令牌(处理 10 个请求), 每 0.1s 固定速率生成</span></span><br><span class="line"><span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平滑预热限流, 1s 内生成 10 个令牌, 有 3s 的预热时间, 前 3s 生成令牌的速率逐渐提升到 0.1s 生成一个令牌, 3s 后才维持速率统一。</span></span><br><span class="line"><span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">10.0</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>下面是 <code>create()</code> 方法的方法签名，有多个重载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(<span class="type">double</span> permitsPerSecond)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(<span class="type">double</span> permitsPerSecond, Duration warmupPeriod)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title function_">create</span><span class="params">(<span class="type">double</span> permitsPerSecond, <span class="type">long</span> warmupPeriod, TimeUnit unit)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>下面我们再来介绍一下用于获取令牌的两个方法：<code>acquire()</code> 与 <code>tryAcquire()</code> ，只有获取到令牌的线程才能够处理请求，这是令牌桶的原理。</p><p>先来看 <code>acquire()</code> 方法：每次处理一个请求之前，调用 <code>rateLimiter.acquire()</code> 方法来尝试获取令牌。如果没有获得令牌，程序会被阻塞，直到获取到令牌为止。</p><p><code>acquire()</code> 的多个重载方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参方法, 一次获取一个令牌</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acquire</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定个数的令牌, 用于批量请求/任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>再来看 <code>tryAcquire()</code> 方法：如果不希望阻塞线程，可以使用 <code>tryAcquire()</code> 方法。它会尝试获取令牌，并返回一个布尔值表示是否成功。</p><p><code>tryAcquire()</code> 的多个重载方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> tryAcquire(<span class="number">1</span>, <span class="number">0</span>, MICROSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(Duration timeout)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(<span class="keyword">permits</span>, <span class="number">0</span>, MICROSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, Duration timeout)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>方法各个参数的意义一看就明白了，这里不做过多解释。</p><p>下面就简单写两个示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 每秒 10 个令牌, 预热 3 秒</span></span><br><span class="line">    <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">10.0</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 尝试获取令牌</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> rateLimiter.tryAcquire();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="comment">// 拿到令牌, 处理业务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;处理业务 ...&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取令牌失败, 拒绝或重试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;拒绝处理业务 ...&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 每秒 10 个令牌, 预热 3 秒</span></span><br><span class="line">    <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">10.0</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 批量获取令牌</span></span><br><span class="line">            <span class="keyword">if</span> (rateLimiter.tryAcquire(<span class="number">5</span>)) &#123;</span><br><span class="line">                <span class="comment">// 拿到令牌, 处理业务</span></span><br><span class="line">                System.out.println(<span class="string">&quot;处理业务 ...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取令牌失败, 拒绝或重试</span></span><br><span class="line">                System.out.println(<span class="string">&quot;拒绝处理业务 ...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCodeEnum.TOO_MANY_REQUEST);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RateLimiter 是线程安全的。</p></blockquote><h1 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>分布式限流针对的分布式&#x2F;微服务应用架构应用，在这种架构下，单机限流就不适用了，因为会存在多种服务，并且一种服务也可能会被部署多份。</p><p>分布式限流常见的方案：</p><ul><li><strong>借助中间件限流</strong>：可以借助 Sentinel 或者使用 Redis 来自己实现对应的限流逻辑。</li><li><strong>网关层限流</strong>：比较常用的一种方案，直接在网关层把限流给安排上。不过，通常网关层限流通常也需要借助到中间件&#x2F;框架。就比如 Spring Cloud Gateway 的分布式限流实现 <code>RedisRateLimiter</code> 就是基于 Redis+Lua 来实现的，再比如 Spring Cloud Gateway 还可以整合 Sentinel 来做限流。</li></ul><p>我们可以使用 Redis + Lua 脚本的形式实现分布式限流。如果不想自己写 Lua 脚本的话，也可以直接利用 Redisson 中的 <code>RRateLimiter</code> 来实现分布式限流，其底层实现就是基于 Lua 代码+令牌桶算法。</p><h2 id="基于-Redisson-实现分布式限流"><a href="#基于-Redisson-实现分布式限流" class="headerlink" title="基于 Redisson 实现分布式限流"></a>基于 Redisson 实现分布式限流</h2><h3 id="引入-Redisson-依赖并配置客户端"><a href="#引入-Redisson-依赖并配置客户端" class="headerlink" title="引入 Redisson 依赖并配置客户端"></a>引入 Redisson 依赖并配置客户端</h3><ol><li>引入 Redisson 依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redisson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.45.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置 Redisson 的客户端</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis 端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化客户端</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 配置客户端(单机), 集群模式替换为 useClusterServers()</span></span><br><span class="line">        config.useSingleServer()</span><br><span class="line">                .setAddress(<span class="string">&quot;redis://&quot;</span> + host + <span class="string">&quot;:&quot;</span> + port)</span><br><span class="line">                .setPassword(password)</span><br><span class="line">                .setDatabase(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我是选择基于 <code>@ConfigurationProperties</code> 注解去读取配置文件来动态获取 Redis 相关的连接数据</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.128</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">10000</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>Redisson 是基于 Netty 实现的，不直接依赖于 Redis，因此无需额外引入 Redis 的依赖。</li><li>使用 Docker 开启 Redis，并配置好 Redis 连接信息即可。</li></ul></blockquote><h3 id="实现-Redisson-限流"><a href="#实现-Redisson-限流" class="headerlink" title="实现 Redisson 限流"></a>实现 Redisson 限流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLimiterManager</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行限流操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 限流标识, 比如用户 id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doRateLimit</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建限流器</span></span><br><span class="line">        <span class="type">RRateLimiter</span> <span class="variable">rRateLimiter</span> <span class="operator">=</span> redissonClient.getRateLimiter(key);</span><br><span class="line">        <span class="comment">// 1s 内最多访问 2 次</span></span><br><span class="line">        rRateLimiter.trySetRate(RateType.OVERALL, <span class="number">2</span>, Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 每次请求消耗 1 个令牌</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> rRateLimiter.tryAcquire(<span class="number">1</span>); <span class="comment">// 无参默认就是 1, 这里可以直接使用无参方法</span></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;获取令牌失败&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCodeEnum.TOO_MANY_REQUEST);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面进行一些说明：</p><ul><li>获取限流器</li></ul><p>需要传入一个参数作为标识, 比如 <code>userId</code> , <code>IP</code> 等唯一性的字符串, 这里我选择作为方法参数传入, 由调用方指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RRateLimiter <span class="title function_">getRateLimiter</span><span class="params">(String name)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li>设置访问频率</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">trySetRate</span><span class="params">(RateType mode, <span class="type">long</span> rate, Duration rateInterval)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">trySetRate</span><span class="params">(RateType mode, <span class="type">long</span> rate, Duration rateInterval, Duration keepAliveTime)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>第一个参数是表示限流方式，有两个模式可以选择：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RateType</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    OVERALL,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单机限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PER_CLIENT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数与第三个参数一起看，一个是速率，一个是速率的时间间隔，比如 <code>2, Duration.ofSeconds(1)</code> 就表示 1s 处理两个请求；又比如 <code>300, Duration.ofHours(1)</code> 表示 1 小时处理 300 个请求。</p><p>第四个参数可选，表示限流器删除之前等待的时间，规定时间内如果桶中还没有令牌的话，限流器就会被删除。</p><blockquote><p>Redisson 还提供了 <code>trySetRateAsync()</code> ，用于异步的设置。</p></blockquote><ul><li>获取令牌</li></ul><p>获取令牌的方法与 Guava 类似，还是通过 <code>acquire()</code> 与 <code>tryAcquire()</code> 方法，只不过这两个方法都是同步方法。</p><p>Redisson 也提供了对应的异步方法来进行获取：<code>acquireAsync()</code> 与 <code>tryAcquireAsync()</code> 。</p><ul><li>使用限流</li></ul><p>我们只需要在 <code>ServiceImpl</code> 中注入定义的限流 Bean，然后在需要限流的方法中调用即可。</p><p>简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 限流</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">IDENTIFICATION</span> <span class="operator">=</span> loginUser.getId();</span><br><span class="line">redisLimiterManager.doRateLimit(IDENTIFICATION);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><blockquote><p>本篇博客借鉴于 <a href="https://javaguide.cn/high-availability/limit-request.html">JavaGuide</a>，并在此基础上添加个人的理解。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 高可用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redisson </tag>
            
            <tag> 分布式限流 </tag>
            
            <tag> 固定窗口 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 漏桶 </tag>
            
            <tag> 令牌桶 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 高可用 </tag>
            
            <tag> Guava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存击穿、缓存穿透、缓存雪崩问题及解决方案</title>
      <link href="/2025/08/25/Redis/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2025/08/25/Redis/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><h2 id="什么是缓存击穿？"><a href="#什么是缓存击穿？" class="headerlink" title="什么是缓存击穿？"></a>什么是缓存击穿？</h2><p>缓存击穿指的是某个热点 key 在缓存中突然失效了，导致大量的请求都到达数据库，给数据库带来了不必要的压力。</p><h2 id="缓存击穿的解决方案"><a href="#缓存击穿的解决方案" class="headerlink" title="缓存击穿的解决方案"></a>缓存击穿的解决方案</h2><ul><li>互斥锁&#x2F;分布式锁</li><li>逻辑过期</li><li>互斥锁&#x2F;分布式锁 + 逻辑过期</li><li>定时刷新</li></ul><h3 id="互斥锁-分布式锁"><a href="#互斥锁-分布式锁" class="headerlink" title="互斥锁&#x2F;分布式锁"></a>互斥锁&#x2F;分布式锁</h3><p>互斥锁&#x2F;分布式锁的具体原理就是：利用锁的互斥性，保证多个请求中只有一个请求能够到达数据库并访问数据库进行更新缓存，其它的请求阻塞等待。</p><p>需要做一个双重检测的机制，避免重复查询。其他请求拿到锁之后先判断缓存中是否存在数据，存在数据直接返回即可。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="string">&quot;hot_key&quot;</span>;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cached</span> <span class="operator">=</span> redis.get(cacheKey);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cached != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cached; <span class="comment">// 缓存命中, 直接返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 尝试获取分布式锁(比如用 Redis 的 SETNX 或 RedLock)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span> + cacheKey;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> redis.setIfAbsent(lockKey, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS); <span class="comment">// 设置 10 秒超时</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (locked) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 双重检查, 可能其他线程已经重建好缓存了</span></span><br><span class="line">        cached = redis.get(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (cached != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cached;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 查数据库</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">dbData</span> <span class="operator">=</span> queryFromDB(cacheKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 写回缓存</span></span><br><span class="line">        redis.set(cacheKey, dbData, <span class="number">3600</span>); <span class="comment">// 设置新的过期时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dbData;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        redis.del(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没抢到锁, 短暂等待后重试, 或者直接返回旧数据/默认值</span></span><br><span class="line">    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> getFromCacheWithLock(cacheKey); <span class="comment">// 重试, 或者 return 默认值/兜底数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式数据一致性比较强，但是需要阻塞等待，会对性能造成一定影响。</p><h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><p>逻辑过期就是指不设置缓存 key 的过期时间，使其永不过期，由我们在保存缓存数据的时候手动维护一个 <code>expireTime</code> 字段到 Redis 当中。比如保存 JSON 或 Map 的时候显式的指定一个 <code>expireTime</code> 字段，字段中保存当前时间的时间戳 + 手动的过期时间。</p><p>每次获取数据的时候，解析相应的 <code>expireTime</code> 字段，与当前的时间戳进行比较，若保存的时间戳大于当前时间，则表示还没有逻辑过期，否则就已经过期，过期之后可以开启一个新的线程更新缓存或者使用消息队列去更新缓存。</p><p>该方案可能会存在短暂时间的脏数据，但是不需要阻塞请求。</p><h3 id="互斥锁-分布式锁-逻辑过期"><a href="#互斥锁-分布式锁-逻辑过期" class="headerlink" title="互斥锁&#x2F;分布式锁 + 逻辑过期"></a>互斥锁&#x2F;分布式锁 + 逻辑过期</h3><p>实际环境中，都是二者一起去使用来防止缓存击穿的，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑过期时间: 例如 10 分钟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">LOGICAL_EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存 key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CACHE_KEY</span> <span class="operator">=</span> <span class="string">&quot;product:123&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDataWithLogicalExpire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> redisTemplate.opsForValue().get(CACHE_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 缓存为空, 需要重建</span></span><br><span class="line">        <span class="keyword">if</span> (jsonStr == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rebuildCacheAndReturn();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 解析 JSON 获取 expireTime</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSON.parseObject(jsonStr);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">expireTime</span> <span class="operator">=</span> jsonObject.getLong(<span class="string">&quot;expireTime&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;data&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 判断是否逻辑过期</span></span><br><span class="line">        <span class="keyword">if</span> (expireTime &gt; System.currentTimeMillis()) &#123;</span><br><span class="line">            <span class="comment">// 未过期，直接返回数据</span></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已逻辑过期，触发异步缓存更新（防止击穿）</span></span><br><span class="line">            asyncRefreshCache();</span><br><span class="line">            <span class="comment">// 依然返回旧数据（可容忍短暂脏读）</span></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步刷新缓存(可用线程池或消息队列)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">asyncRefreshCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 提交到线程池执行, 避免阻塞主线程</span></span><br><span class="line">        ThreadPool.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取最新数据</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">freshData</span> <span class="operator">=</span> queryFromDatabase();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 构造新的 JSON, 设置新的逻辑过期时间</span></span><br><span class="line">                <span class="type">JSONObject</span> <span class="variable">newJson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">                newJson.put(<span class="string">&quot;data&quot;</span>, freshData);</span><br><span class="line">                newJson.put(<span class="string">&quot;expireTime&quot;</span>, System.currentTimeMillis() + LOGICAL_EXPIRE_TIME);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新 Redis 缓存</span></span><br><span class="line">                redisTemplate.opsForValue().set(CACHE_KEY, newJson.toJSONString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 记录日志, 避免影响主流程</span></span><br><span class="line">                log.error(<span class="string">&quot;异步刷新缓存失败&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首次缓存为空时, 同步重建并返回</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">rebuildCacheAndReturn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 加分布式锁, 防止缓存击穿(多个线程同时重建)</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">locked</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock:&quot;</span> + CACHE_KEY, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">            <span class="comment">// 未获取到锁, 短暂等待或直接查库(降级)</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">return</span> getDataWithLogicalExpire(); <span class="comment">// 递归重试</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 查询数据库</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">freshData</span> <span class="operator">=</span> queryFromDatabase();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建带逻辑过期的 JSON</span></span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">newJson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">            newJson.put(<span class="string">&quot;data&quot;</span>, freshData);</span><br><span class="line">            newJson.put(<span class="string">&quot;expireTime&quot;</span>, System.currentTimeMillis() + LOGICAL_EXPIRE_TIME);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写入 Redis</span></span><br><span class="line">            redisTemplate.opsForValue().set(CACHE_KEY, newJson.toJSONString());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> freshData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            redisTemplate.delete(<span class="string">&quot;lock:&quot;</span> + CACHE_KEY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">queryFromDatabase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟查库</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Data from DB&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定时刷新"><a href="#定时刷新" class="headerlink" title="定时刷新"></a>定时刷新</h3><p>使用定时任务框架，比如 Spring Scheduler、xxl-job 等，针对每个热点 key 进行记录过期时间，在过期时间之前刷新数据，比如 1 分种过期时间进行数据刷新。</p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><h2 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h2><p>缓存穿透指的是数据在缓存和数据库中都不存在，从而导致大量的请求直接访问数据库，造成数据库压力过载，甚至出现宕机。</p><h2 id="缓存穿透解决方案"><a href="#缓存穿透解决方案" class="headerlink" title="缓存穿透解决方案"></a>缓存穿透解决方案</h2><p>缓存穿透的解决可以分为多个步骤。</p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>首先对请求参数做好校验，拦截非法的请求。对于一些异常的用户或者异常的 IP 直接进行限流或者设置黑名单禁止访问，可以在网关层中进行拦截。</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>对于数据库中查不到的数据缓存一个空值进行返回，同时设置一个较短的过期时间，避免后续增加了该数据后反而查不到。</p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>如果恶意用户构造大量不存在的数据疯狂攻击我们，那么缓存空值就力不从心了，可以使用布隆过滤器来实现。写数据库的时候同时写布隆过滤器，后续打来的请求通过布隆过滤器进行判断。</p><p>布隆过滤器就是把数据经过多个 hash 函数进行计算得到多个 hash 值，然后把 hash 值映射到一个 bitmap 中，把对应位置修改为 1。请求来了，就对这些数据用 hash 函数做计算，然后看看这几个 hash 值对应的 bitmap 的那个位置上是不是 1，是 1 说明有，是 0 说明没有。</p><p>但是布隆过滤器是存在一定误判的可能的。且布隆过滤器不支持删除，因为无法确定哪个哈希值是哪个元素设置的。</p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><h2 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h2><p>缓存雪崩指的是在同一时期大量的缓存 key 突然 <strong>同时过期</strong>，导致所有的请求都直接访问数据库，从而导致数据库的流量激增，压力骤增，最终导致宕机。</p><h2 id="缓存雪崩解决方案"><a href="#缓存雪崩解决方案" class="headerlink" title="缓存雪崩解决方案"></a>缓存雪崩解决方案</h2><ul><li>随机过期时间</li><li>缓存永不过期</li><li>缓存预热</li><li>多级缓存</li></ul><h3 id="随机过期时间"><a href="#随机过期时间" class="headerlink" title="随机过期时间"></a>随机过期时间</h3><p>该方案就是在给定一个固定的过期时间之后再随机加上一个随机数，从而避免大量缓存数据的同时过期。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis 优化分页查询</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queryRequest 查询参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 分页结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;PictureVO&gt; <span class="title function_">listPictureVOByPageWithCache</span><span class="params">(PictureQueryRequest queryRequest)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 构建 Redis Key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(queryRequest);</span><br><span class="line">    <span class="type">String</span> <span class="variable">md5Str</span> <span class="operator">=</span> DigestUtils.md5DigestAsHex(jsonStr.getBytes());</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;picture:listPictureVOByPage:&quot;</span> + md5Str;</span><br><span class="line">    <span class="comment">// 2. 先查询 Redis</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">valueData</span> <span class="operator">=</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(valueData)) &#123;</span><br><span class="line">        <span class="comment">// 缓存中存在数据, 直接返回(避免泛型擦除)</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(valueData, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;Page&lt;PictureVO&gt;&gt;() &#123;</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 不存在, 查询数据库</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> queryRequest.getCurrent();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> queryRequest.getPageSize();</span><br><span class="line">    Page&lt;Picture&gt; picturePage = <span class="built_in">this</span>.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, pageSize), <span class="built_in">this</span>.getQueryWrapper(queryRequest));</span><br><span class="line">    Page&lt;PictureVO&gt; pictureVOPage = <span class="built_in">this</span>.getPictureVOPage(picturePage);</span><br><span class="line">    <span class="comment">// 4. 写入数据到 Redis</span></span><br><span class="line">    <span class="comment">// 设置过期时间(添加随机时间, 防止缓存雪崩)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">300</span> + RandomUtil.randomInt(<span class="number">0</span>, <span class="number">300</span>);</span><br><span class="line">    redisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(pictureVOPage), timeout, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> pictureVOPage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存永不过期"><a href="#缓存永不过期" class="headerlink" title="缓存永不过期"></a>缓存永不过期</h3><p>该方案就是针对于几乎不会改变的数据不设置过期时间，在有需要修改的场景进行异步删除或更新即可。</p><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><p>利用定时任务提前对缓存做预热，保证用户直接查询缓存而不是数据库。</p><h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><p>结合本地缓存与分布式缓存一起使用，并设置不同的过期时间，避免对数据库直接造成请求。比如本地缓存 Caffeine 结合分布式缓存 Redis 共同构成多级缓存，避免缓存雪崩。</p><p>下面是一个我之前项目中使用的一个多级缓存示例。</p><img  src=http://www.plantuml.com/plantuml/svg/ZP7BJW8n58RtVOecB9GToY3Y68tYqfNw0hNjI0DEIMVK6ED2ZSRx3JL6lCVRGW4Jl8k-3Etm68uC6X0JtJJfVyv_llFdDC1IviqfPDHslbX8gUC7-Re6h3WpaqYWOMZ54E5Zp1o21afO5806A3DxnQS5TJVbN2t9sHadVrpdGjXceymUXnEW6-7uaE0Z9edo11VjxRqSeqGKuHZjw80-h15i6FLTVPGmwy-k7cIZGMJLz711g2ZNeI-e1P4M0Fqs4dP5QegqXaEQA_5aHI4u6D92e4i8FbQH0gI56WJqCfCEn1YEczIoO3EOh8f_S59ykQyBpepwoD178nJJ7wkru70eJ42VroPCAc1Ju9DWCpj1eJpRSvuldTUKlDbL-HUvU2NJRm1Odqb0crezLrltfUo3kftMtU_HUIbxglQlvNxEiy0eCWpghgy3TwL6jPkLwnToer1ylEdqGpj6pRBe1ssbzosPFgpsgksSMideBeid0NMF3XjTi_yB8-VdvEEC6xj2Ab_gJunAvzLEhXgZVx6z2V1VSAyidrFwRoFbvdBDi6_4jwrsl4cOuRqV><p>1、引入依赖 (JDK11+)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Caffeine --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、Caffeine 缓存工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Caffeine 缓存工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaffeineUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cache&lt;String, String&gt; LOCAL_CACHE = Caffeine.newBuilder()</span><br><span class="line">    .initialCapacity(<span class="number">1024</span>) <span class="comment">// 初始容量</span></span><br><span class="line">    .maximumSize(<span class="number">10000L</span>) <span class="comment">// 最大容量</span></span><br><span class="line">    .expireAfterWrite(<span class="number">5L</span>, TimeUnit.MINUTES) <span class="comment">// 5 分钟过期</span></span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Cache&lt;String, String&gt; <span class="title function_">getCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LOCAL_CACHE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、构建多级缓存示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis + Caffeine 多级缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queryRequest 查询参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 分页结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;PictureVO&gt; <span class="title function_">listPictureVOByPageWithCache</span><span class="params">(PictureQueryRequest queryRequest)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 构建 Key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(queryRequest);</span><br><span class="line">    <span class="type">String</span> <span class="variable">md5Str</span> <span class="operator">=</span> DigestUtils.md5DigestAsHex(jsonStr.getBytes());</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;picture:listPictureVOByPage:&quot;</span> + md5Str;</span><br><span class="line">    <span class="comment">// 2. 先查询 Caffeine</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">valueData</span> <span class="operator">=</span> CaffeineUtil.getCache().getIfPresent(key);</span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(valueData)) &#123;</span><br><span class="line">        <span class="comment">// 存在, 直接返回</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(valueData, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;Page&lt;PictureVO&gt;&gt;() &#123;</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 不存在, 查询 Redis</span></span><br><span class="line">    valueData = redisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(valueData)) &#123;</span><br><span class="line">        <span class="comment">// redis 中存在, 先更新本地缓存, 再返回结果</span></span><br><span class="line">        CaffeineUtil.getCache().put(key, valueData);</span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(valueData, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;Page&lt;PictureVO&gt;&gt;() &#123;</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 都不存在, 查询数据库</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> queryRequest.getCurrent();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> queryRequest.getPageSize();</span><br><span class="line">    Page&lt;Picture&gt; picturePage = <span class="built_in">this</span>.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, pageSize), <span class="built_in">this</span>.getQueryWrapper(queryRequest));</span><br><span class="line">    Page&lt;PictureVO&gt; pictureVOPage = <span class="built_in">this</span>.getPictureVOPage(picturePage);</span><br><span class="line">    <span class="comment">// 5. 写入数据到 Caffeine</span></span><br><span class="line">    CaffeineUtil.getCache().put(key, JSONUtil.toJsonStr(pictureVOPage));</span><br><span class="line">    <span class="comment">// 6. 写入数据到 Redis</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">300</span> + RandomUtil.randomInt(<span class="number">0</span>, <span class="number">300</span>);</span><br><span class="line">    redisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(pictureVOPage), timeout, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> pictureVOPage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不可避免的缓存雪崩突发情况"><a href="#不可避免的缓存雪崩突发情况" class="headerlink" title="不可避免的缓存雪崩突发情况"></a>不可避免的缓存雪崩突发情况</h2><p>针对于 Redis 突然宕机，或者内存不够导致淘汰其他缓存数据，或者机房被洪水淹了等不可抗力因素导致的缓存雪崩问题，我们有如下的对应方案：</p><p>1、做好 Redis 的高可用，要么搭建主从 + 哨兵节点要么搭建多主多从集群。</p><p>2、做好服务的降级限流熔断的服务保护措施，做好兜底。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 中 SQL 的执行流程与编写顺序</title>
      <link href="/2025/08/24/MySQL/MySQL%20%E4%B8%AD%20SQL%20%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%BC%96%E5%86%99%E9%A1%BA%E5%BA%8F/"/>
      <url>/2025/08/24/MySQL/MySQL%20%E4%B8%AD%20SQL%20%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%BC%96%E5%86%99%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一条-SQL-语句是如何执行的？"><a href="#一条-SQL-语句是如何执行的？" class="headerlink" title="一条 SQL 语句是如何执行的？"></a>一条 SQL 语句是如何执行的？</h1><p>先说结论：一条 SQL 语句的执行需要经历：<strong>连接器</strong>、<strong>缓存层</strong>、<strong>解析器</strong>、<strong>优化器</strong>、<strong>执行器</strong> 五个步骤。下面以一个买鸡蛋的例子来进行说明 SQL 的具体执行流程。</p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>首先买鸡蛋的第一步就是：让妈妈先找到我，给我一个去买鸡蛋的指令。</p><p>相应的，我们需要执行 SQL，第一步就是先连接上数据库，通过网络把 SQL 语句传输过去，然后数据库才能帮我执行 SQL 语句。</p><p>这就是连接器的工作，连接器就是客户端与数据库之间进行连接，主要步骤是：</p><ul><li>先进行 TCP 的三次握手与数据库建立连接</li><li>校验客户端的用户名与密码是否正确，不正确则报错</li><li>做权限校验，判断当前用户是否有权限访问数据库</li></ul><h2 id="缓存层"><a href="#缓存层" class="headerlink" title="缓存层"></a>缓存层</h2><p>现在我收到了买鸡蛋的指令，下一步就直接出门去买吗？当然不是！我们应该先看看家里还有没有剩下的鸡蛋，有就直接用呗，没有了才去买。</p><p>相应的，连接上数据库之后，需要先查询缓存。以传输的 SQL 语句作为 key，以查询的结果作为 value，如果缓存中存在 value，那就说明之前执行过一样的SQL 语句，那我就直接拿来用呗，不用重复执行了。</p><p><strong>为什么 MySQL 会有缓存存在？</strong></p><p>程序有时间局部性，当某一段代码或者某一段指令被执行时，很有可能这段代码还会被重复执行。或者说某一段内存位置被访问时，很有可能这个内存位置还会被再次访问，这是因为代码中会存在大量的循环、递归等操作，导致某段指令被重复执行，这就是时间局部性的原理。所以一条被执行过的 SQL，在未来很有可能被再次执行，这就是为啥要对 SQL 做缓存。</p><p><strong>为什么 MySQL 8.0 又去掉了缓存？</strong></p><p>因为一旦表数据一变化，那 SQL 执行的结果就有可能不一样，所以表数据变化时就应该删除缓存。而实际上很多 SQL 在执行的时候，where 条件是会不断变化的，这就导致了 SQL 看着都差不多，但是条件稍微不一样它就走不了缓存，所以查询缓存的命中率并不高，MySQL 在 8.0 就把查询缓存去掉了。</p><h2 id="解析层"><a href="#解析层" class="headerlink" title="解析层"></a>解析层</h2><p>回到买鸡蛋的问题，现在家里确定没有鸡蛋了，要去买。但是还需要思考一个问题：我想要吃鸡蛋吗？我不想吃就要告诉我妈妈不买了，我想吃就要考虑买多少个。</p><p>相应的，SQL 语句下一步到达解析器。解析器就是判断 SQL 语句的具体想法，分为三步：</p><ul><li><p>词法分析。拆分 SQL 语句的关键词，比如 <code>select</code> 、<code>from</code> 、<code>where</code> 、<code>order by</code> 等。</p></li><li><p>语法分析。判断 SQL 语句的编写语法是否是正确的，不正确就报错；正确的话就构建语法解析树，方便后续获得表名、字段名。</p></li><li><p>检查表，判断字段是否存在。</p></li></ul><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>现在我确定要买鸡蛋，我确实想吃鸡蛋，我也确定了要买 20 个鸡蛋。接下来就需要计划怎么买了：是去超市买还是去菜市场买？是骑车去买还是坐公交车去买？</p><p>相应的，SQL 语句接下来就到了优化器。优化器的职责就是给 SQL 制定一个计划：怎么执行 SQL 是最快的，是走索引还是全表扫描，走索引的话走哪个索引？</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>现在我的计划完成了，然后就是执行计划：骑车去菜市场买鸡蛋。所以我就还需要跟卖鸡蛋的老板交流，付钱。</p><p>相应的，SQL 语句最后抵达执行器。执行器的任务就是与存储引擎层进行交互，执行相应的 SQL 语句，然后从存储引擎中拿到结果返回。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一条 SQL 语句的执行顺序可以以下图作为参考：<br><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250824171942925.png" alt="img" style="zoom:57%;" /></p><h1 id="SQL-语句顺序"><a href="#SQL-语句顺序" class="headerlink" title="SQL 语句顺序"></a>SQL 语句顺序</h1><h2 id="SQL-编写顺序"><a href="#SQL-编写顺序" class="headerlink" title="SQL 编写顺序"></a>SQL 编写顺序</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">join</span> 多表查询</span><br><span class="line"><span class="keyword">where</span> 条件</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 分组</span><br><span class="line"><span class="keyword">having</span> 分组后过滤</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 查询结果排序</span><br><span class="line">limit 查询结果分页</span><br></pre></td></tr></table></figure><h2 id="SQL-执行顺序"><a href="#SQL-执行顺序" class="headerlink" title="SQL 执行顺序"></a>SQL 执行顺序</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">join</span> 多表查询</span><br><span class="line"><span class="keyword">where</span> 查询条件</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 分组</span><br><span class="line"><span class="keyword">having</span> 分组后过滤</span><br><span class="line"><span class="keyword">select</span> 返回字段名</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 查询结果排序</span><br><span class="line">limit 查询结果分页</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 持久化机制</title>
      <link href="/2025/08/24/Redis/Redis%20%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/08/24/Redis/Redis%20%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis-的持久化机制"><a href="#Redis-的持久化机制" class="headerlink" title="Redis 的持久化机制"></a>Redis 的持久化机制</h1><p>讨论 Redis 持久化机制之前，我们应该先想一下 MySQL 是怎么做的数据持久化：先把数据保存到日志当中，再执行 SQL 语句，这样就保证了 MySQL 突然宕机后的数据恢复能力，直接读取日志即可恢复。</p><p>那么对于 Redis 来讲，也是一样的操作：<strong>写日志</strong>。Redis 中提供了两种持久化策略，一种是 RDB 持久化、一种是 AOF 持久化。</p><h2 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h2><p>RDB 持久化本质上保存的是 <strong>数据快照</strong>，它把 Redis 中保存的数据以二进制的形式写入到一个 RDB 文件当中，该文件默认是 <code>dump.rdb</code> 。</p><p>需要注意的是 RDB 持久化保存的是当前时间下 Redis 内的二进制全量数据，这就会引发一个问题：RDB 持久化每次都保存 Redis 的全量数据，那这个过程是不是很慢？</p><p>答案是肯定的。而 Redis 提供了两个命令来实现 RDB 的持久化：<code>save</code> 与 <code>bgsave</code>。</p><p>先来看 <code>save</code> ：save 是在主线程去保存 RDB 数据快照，这样势必就会带来一个问题：阻塞主进程的读写命令执行，所以这种方式是我们所不推荐的。</p><p>再来看 <code>bgsave</code> ：bgsave 表示开启一个子进程来执行 RDB 持久化，这样就不会阻止主进程读写的命令了，这是 RDB 持久化的默认选择。实际上这种方式的持久化机制使用了一种 “写时复制” 的思想，在 JDK 中的体现就是 <code>CopyOnWriteArraylist</code> 类。</p><p>但是即使是使用 <code>bgsave</code> 开启一个子进程来执行 RDB 持久化，不还是存在 RDB 持久化过程缓慢的缺点吗？</p><p>是的，这是不可避免的。而由于 RDB 过程比较慢，我们最好手动设置一个持久化频率来避免频繁地进行 RDB 持久化。通过配置文件可以配置在 x 秒内有 y 个 key 发生变化就进行 RDB 持久化操作，或者直接固定好时间，比如 5 分钟执行一次持久化。但是如果在这个过程中 Redis 出现了宕机，那么就会相应的丢失规定时间内的数据。</p><p>这就是 RDB 持久化的缺点：<strong>过程缓慢且容易丢失数据</strong>。但 RDB 持久化也是具有一定的优势的：RDB 内存储的是二进制的全量数据，Redis 故障恢复后直接读取数据写入内存就能恢复，也就是说，<strong>RDB 持久化方式下 Redis 的故障恢复能力很快</strong>。</p><p>在这里就又引出了一个问题：<strong>子进程保存 RDB 快照时，主进程还能写入或者修改数据吗？</strong></p><p>答案是可以的。上面我们提到 RDB 的 <code>bgsave</code> 方式是基于 “写时复制” 的思想，这样就保证了 <strong>RDB 持久化的过程中也是可以在主线程进行数据的写入或修改操作的</strong>。</p><p>主进程 fork 子进程后，并不是把所有数据都复制一份给子进程，而是使主进程与子进程共享相同的内存页面。也就是说仅仅复制了页表，使二者指向同一个物理地址，这样可以加快 fork 的速度，减少性能消耗。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250824151337254.png" alt="img" style="zoom:67%;" /><p>如果此时收到了写命令，那么主进程会对数据所在的页进行复制一份，<strong>在副本上进行修改</strong>，此时子进程还是指向的老的页，数据是没有发生变化的，这就是 <strong>写时复制</strong> 的思想。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250824151424735.png" alt="img" style="zoom:67%;" /><h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><p>RDB 是保存二进制全量数据进行持久化，那我们可不可以试想一下另一种方案：<strong>不保存全部的数据了，只保存写命令的操作。即使 Redis 宕机了，那等 Redis 重启之后再次执行一遍这些写命令，不也是可以恢复数据吗，这就是 AOF 的思想</strong>。</p><p>AOF 持久化机制是什么样的？我们不妨先想想 MySQL 的思路：<strong>先把数据写入到 Buffer Pool 缓冲区，然后在某个时间段异步的刷入到磁盘当中</strong>。所以对于 Redis 的 AOF 来讲，过程是类似的：</p><ul><li>先执行主线程的命令</li><li>然后记录命令到 AOF 缓冲区</li><li>其次写入操作系统的内核缓冲区 Page Cache</li><li>最后在某个时间段内刷入到磁盘当中</li></ul><p>那么在 AOF 中到底什么时间才会把数据刷入磁盘呢，Redis 给我们提供了三种选择：<code>always</code>、<code>no</code>、<code>everysec</code> 。</p><p>先来看 <code>always</code> ：这种方式是通过主线程每次执行完命令就立刻刷入到磁盘当中，该方式能够最大程度的保证数据的不丢失，但是是由主线程来操作的，会对主线程执行命令时的性能造成一定影响。</p><p>再来看 <code>no</code> ：这种方式是说不主动进行刷盘，而是由操作系统自己来决定什么时候把数据刷入磁盘。这种方式虽然缓解了主线程的性能影响，但是其刷盘时机是不确定的，会一定程度上增加数据丢失的风险。 </p><p>最后看 <code>everysec</code> ：该方式是指每次执行完命令后，先把命令写入到缓冲区，然后每隔 1 秒刷一次盘，这是对前面两种方式的一种折中选择。在该方式下，即使丢失数据也只会丢失 1 秒内的数据，既保证了 Redis 执行命令的性能，又不会丢失太多的数据。</p><p>下面我们来看两个问题：</p><p><strong>1、always 一定能够保证不丢失数据吗？</strong></p><p>always 也不能保证数据一定不丢失。因为 Redis 是先执行命令再写入 AOF，如果写入 AOF 这段时间宕机，那么 AOF 就不能保证数据的存在。</p><p><strong>2、为什么 AOF 先执行命令再写入日志，而不是像 MySQL 先写入日志，再执行命令？</strong></p><p><strong>从 MySQL 的角度来看</strong>：MySQL 是关系型数据库，其根本的工作最大程度上就是保证数据不能丢失。其核心是保证事务的 ACID，保证数据的持久性，数据是坚决不能丢的，因此选择先写入日志，再执行命令。</p><p><strong>而对于 Redis 来说</strong>，虽然也是数据库，但往往 Redis 的应用场景是作为缓存存在，也就是说是作为临时存储数据的桥梁，实际数据还是以 MySQL 中的数据为主。而我们用缓存最大的目的不就是 <strong>快</strong> 嘛。所以 Redis 先执行命令再写入日志 (写入 AOF 可以理解为写日志)，完全符合其 <strong>快</strong> 的特点。</p><p>换一个角度再来看：Redis 先执行命令，那么就说明了 Redis 执行的命令是有效的，这样在执行 AOF 的时候就不需要再进行命令合法性的检查了，可以直接写入。</p><p>假设有如下的场景：<code>set key1 1</code>、<code>set key1 2</code>、<code>set key1 3</code> ……、<code>set key1 99999</code> ，对于这样的一串命令，实际上只有最后一次的命令是有效的，前面的命令都是历史值，我们不关心。</p><p>但是 AOF 是会记录所有的写命令的啊，这样一来不就导致了 AOF 文件过大，且 Redis 宕机重启后会执行前面一堆的无效命令？</p><p>针对于上述情况，<strong>AOF 提供了重写机制</strong>。</p><p>AOF 重写会根据现有的 AOF 文件进行重写，意思就是：<strong>新建一个新的 AOF 文件用于写入符合要求的有效的命令，形成一个与原 AOF 文件等效的文件，且体积还比原 AOF 文件小</strong>。AOF 重写是 Redis 开启一个新进程实现的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RDB 是全量数据快照，保存慢，需要每隔一段时间保存一次且容易丢数据，但是 Redis 重启恢复数据比较快。 </p><p>AOF 仅保存 Redis 的写命令，保存快且不容易丢数据，但是 Redis 重启后恢复数据需要一条条执行命令，这个过程比较慢。</p><h2 id="RDB-与-AOF-混合持久化"><a href="#RDB-与-AOF-混合持久化" class="headerlink" title="RDB 与 AOF 混合持久化"></a>RDB 与 AOF 混合持久化</h2><p><strong>有没有一种方案能够兼顾 RDB 的故障恢复能力且 AOF 的不易丢失数据的特点呢？</strong> </p><p>Redis 4.0 版本提出了 <strong>RDB 与 AOF 混合持久化</strong> 的方案来实现了二者优点的兼顾，其工作原理是：</p><p>1、在执行 AOF 重写的时候，把当前 Redis 中的数据以 RDB 的方式写入  AOF，把写命令以 AOF 的方式写入 AOF。</p><p>2、这样就形成了重写后的 AOF 文件，前半段是 RDB 的二进制文件，后半段是 AOF 记录的 Redis 写命令。</p><p>3、这样就保证了 Redis 故障恢复能力的速度，还降低了数据丢失的风险。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 日志 </tag>
            
            <tag> Redis </tag>
            
            <tag> 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 中的 MVCC 与事务隔离级别的实现</title>
      <link href="/2025/08/24/MySQL/MySQL%20%E4%B8%AD%E7%9A%84%20MVCC/"/>
      <url>/2025/08/24/MySQL/MySQL%20%E4%B8%AD%E7%9A%84%20MVCC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a>什么是 MVCC？</h1><p><strong>MVCC：Multi-Version Concurrency Control，多版本并发控制</strong>。MVCC 是一种在数据库管理系统中用来提高并发性能的机制。它主要用于在不加锁或减少加锁的情况下，实现事务的隔离性，从而允许多个事务并发读写数据而不会相互阻塞。</p><h1 id="MVCC-的核心机制"><a href="#MVCC-的核心机制" class="headerlink" title="MVCC 的核心机制"></a>MVCC 的核心机制</h1><h2 id="场景引入"><a href="#场景引入" class="headerlink" title="场景引入"></a>场景引入</h2><p>一张数据库表里面存了很多数据，现在有很多并发事务来访问或者修改数据。在并发事务情况下会出现脏读、不可重复读、幻读问题。</p><p>想要解决脏读，就需要读已提交的隔离级别，也就是说要想办法保证一个事务只能读到其他事务已提交的数据；其他事务没提交的数据，不应该被读取到。</p><p>想要解决不可重复读，就需要可重复读隔离级别，也就是说一个事务第一次读取之后，后面每次读到的数据都应该和第一次一样。即便后面有其他事务新提交了数据也不应该读取到。 </p><h2 id="MVCC-的工作机制"><a href="#MVCC-的工作机制" class="headerlink" title="MVCC 的工作机制"></a>MVCC 的工作机制</h2><p>要想实现上述的需求，就需要用到 <strong>MVCC</strong> 了。</p><p>MVCC 维护了一份数据的多个版本，每个事务修改一次，就生成一个对应的版本，让不同的事务去读不同的版本。</p><p>在读已提交的隔离级别下，让事务去读取已经提交的数据版本，这样就能避免脏读；在可重复读的隔离级别下，让事务每次都读取同一个版本的数据，这样每次读到的就都一样了，就能避免不可重复读的问题。 </p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>把修改的数据版本记录到 undo log 日志中，然后给表增加一个隐藏字段：回滚指针。</p><p>让回滚指针指向 undo log 日志，使用回滚指针将历史版本串联为一个链表。这样的话，想读哪个历史版本，沿着链表 一直找就可以了。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250825211816620.png" alt="image-20250825211816445" style="zoom:67%;" /><p>此时就引出了一个问题：<strong>一个事务来查数据，怎么知道我要查哪个版本的数据呢?</strong></p><p>解决方案就是给每个事务分配一个事务 id，事务 id <strong>自增分配</strong>。通过对比事务 id 的大小，就能知道哪个事务创建的早，哪个事务创建的晚。创建比较晚的事务修改的数据不让创建早的事务看到就行了。</p><p>所以我们需要给表再增加一个隐藏字段：修改数据的事务 id。谁修改了它，就把对应的事务 id 记录下来。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250825153432795.png" alt="image-20250825153432631" style="zoom:67%;" /><h3 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h3><p>除了 undo log 日志外，还需要一个东西：readview。readview 中存在 4 个重要的字段：</p><ol><li><code>creator_trx_id</code> ：创建当前 readview 的事务 id。</li><li><code>m_ids</code> ：创建 readview 时，当前数据库中存在但未提交的所有事务 id 列表。</li><li><code>min_trx_id</code> ：事务 id 列表中最小的事务 id。</li><li><code>max_trx_id</code> ：创建 readview 时，应该分配的下一个事务的 id。</li></ol><p>这些字段的作用都体现在下图中：</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250825213803769.png" alt="image-20250825213803676" style="zoom:75%;" /><p>readview 的本质就是描绘了一个创建当前事务时的事务 id 数轴。通过对比数据版本的 <code>trx_id</code> 在数轴的哪个位置就能知道这个数据版本是否对当前事务是可见的。</p><p>主要有以下的几种情况：</p><p><strong>情况一：当前数据的 <code>trx_id</code> 值小于 readview 中的 <code>min_trx_id</code> 值</strong></p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250825214529618.png" alt="image-20250825214529523" style="zoom:75%;" /><p>该情况下表明当前数据的事务 id 比未提交的最小的事务 id 还小，说明这个数据版本在创建 readview 之前就存在了。数据既然早就有了，那么这个数据版本对当前事务就是 <strong>可见的</strong>。</p><p><strong>情况二：当前数据的 <code>trx_id</code> 值大于或等于 readview 中的 <code>max_trx_id</code> 值</strong></p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250825214911438.png" alt="image-20250825214911351" style="zoom:75%;" /><p>如果记录的 <code>trx_id</code> 值大于等于 readview 中的 <code>max_trx_id</code> 的值，就说明这个数据版本是在 readview 创建后才启动某个事务生成的，该数据是新启动的事务创建的数据，所以该情况下的数据版本是对当前事务 <strong>不可见的</strong>。</p><p><strong>情况三：当前数据的 <code>trx_id</code> 值在 <code>min_trx_id</code> 与 <code>max_trx_id</code> 之间，且存在于 <code>m_ids</code> 列表中</strong></p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250825214831577.png" alt="image-20250825214831507" style="zoom:75%;" /><p>如果记录的 <code>trx_id</code> 值在 <code>min_trx_id</code> 与 <code>max_trx_id</code> 之间，且存在于 <code>m_ids</code> 列表中，则说明生成这个数据版本的事务还没有提交，没有提交的事务当然不能被看到了，所以该情况下的数据版本是对当前事务 <strong>不可见的</strong>。</p><p><strong>情况四：当前数据的 <code>trx_id</code> 值在 <code>min_trx_id</code> 与 <code>max_trx_id</code> 之间，但不存在于 <code>m_ids</code> 列表中</strong></p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250825214831577.png" alt="image-20250825214831507" style="zoom:75%;" /><p>如果记录的 <code>trx_id</code> 值在 <code>min_trx_id</code> 与 <code>max_trx_id</code> 之间，但不存在于 <code>m_ids</code> 列表中，则说明生成这个数据版本的事务已经提交了，已经提交的事务当然能被看到，所以该情况下的数据版本是对当前事务 <strong>可见的</strong>。</p><h2 id="一句话总结-MVCC"><a href="#一句话总结-MVCC" class="headerlink" title="一句话总结 MVCC"></a>一句话总结 MVCC</h2><p>每次修改数据就记录修改的事务 id 到隐藏字段，然后生成一个版本记录到 undo log 版本链中，通过回滚指针指向版本链，然后再通过对比 readview 和数据版本的事务 id，就能知道某个版本的数据对当前事务是否是可见的。</p><p>undo log 记录数据版本，readview 来判断数据版本对当前事务的可见性，这就是 MVCC。</p><h1 id="事务隔离级别怎么实现？"><a href="#事务隔离级别怎么实现？" class="headerlink" title="事务隔离级别怎么实现？"></a>事务隔离级别怎么实现？</h1><h2 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h2><p>读未提交不用实现，多个并发事务同时执行就是天然的读未提交，这是说读的时候不用实现，但是写的时候还是需要加锁的，不能同时写一个数据。</p><h2 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h2><p>串行化就是保证事务的单线程执行，直接加锁即可。只有拿到锁的事务才能够去执行，这样就实现了串行化。</p><h2 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h2><p>每次读取数据都会读取到第一次的数据，即使后面有新的事务进行了数据的修改，还是会读取到第一次相同的数据，这就是可重复读。</p><p>怎么保证可重复读每次都读取到相同的数据呢？</p><p>可重复读会在第一次 <code>select</code> 的时候生成一个 readview。readview 是用来判断数据版本是否对当前事务可见的，而可重复读是会 <strong>复用第一次生成的 readview 的</strong>。当生成这个 readview 的时候，哪些版本的数据对当前事务可见就已经固定下来了，后续每次通过同一个 readview 判断数据的可见性，所以每次都读的是同一个数据版本。</p><p>总结来说就是可重复读是通过 MVCC 加复用第一次生成的 readview 来实现的。该隔离级别就是 MySQL 默认的事务隔离级别，解决了不可重复读的问题，不过仍然会出现幻读的现象。</p><h2 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h2><p>读取数据的时候，如果后面有新的事务进行了数据的修改并提交，那么就会读取到最新提交的数据，这就是读已提交。</p><p>读已提交的本质就是每次 <code>select</code> 的时候就生成一个新的 readview，每次都读取新生成的 readview，这样就能保证每次都可以读取到新提交的数据版本。</p><h1 id="可重复读是怎么解决幻读的？"><a href="#可重复读是怎么解决幻读的？" class="headerlink" title="可重复读是怎么解决幻读的？"></a>可重复读是怎么解决幻读的？</h1><p>可重复读是 MySQL 默认的事务隔离级别，解决了脏读和不可重复读的问题，但是仍然会出现幻读的现象。</p><p>我们该怎么解决幻读？</p><p>最直接的方案就是使用串行化隔离级别，不过串行化性能太差，几乎不会使用。所以我们就需要考虑在可重复读的隔离级别下解决幻读，这就涉及到了快照读和当前读。</p><h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h2><p>在可重复读的隔离级别下，当执行普通的 <code>select</code> 语句，则会通过 MVCC 去读，每次都会读到同一个数据版本，这就是快照读。普通的 <code>select</code> 语句通过快照读去避免加锁，每次都读快照，别的事务干了什么是读不到的，因此就不会产生幻读。</p><p>但是也不是永远读不到的。比如你先开启事务，别人后开启事务，但是别人先插入了 id 为 1 的数据，你读不到，然后你以为 id 为 1 的数据不存在，你就插入了 id 为 1 的数据，此时是插入失败的。所以对于插入这种操作必须要读到最新数据才能判断能不能让你插入，这就是当前读。</p><h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>诸如 <code>select ... lock in share mode</code> 的共享锁或 <code>select ... for update</code> 、<code>update</code> 、<code>insert</code> 、<code>delete</code> 的排他锁等的操作就是当前读。当前读读取的是最新版本的数据。</p><p>执行当前读 MySQL 会使用临键锁去锁住数据和数据之间的间隙。加了锁之后就不能执行插入操作了，这样就不会出现幻读问题。</p><p>举例来说，<code>select * from user where id &gt;= 100 for update</code>，查询 id 大于等于 100 的数据，此时使用 <code>... for update</code> 执行当前读。MySQL 会先锁住 <code>id = 100</code> 的数据，让别的事务无法修改；再锁住 <code>(100, ∞)</code> 的区间，让别的事务无法插入 id 大于 100 的数据，这样就避免产生了幻读。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体来说就是：在可重复读的隔离级别下，是通过 <strong>MVCC 快照读和当前读加锁</strong> 的方式来解决幻读的。</p><h2 id="先快照读后当前读产生的幻读"><a href="#先快照读后当前读产生的幻读" class="headerlink" title="先快照读后当前读产生的幻读"></a>先快照读后当前读产生的幻读</h2><p>上述的方案一定程度上解决了可重复读的隔离级别下出现的幻读问题，但是在某些情况下还是会出现幻读的问题，比如 <strong>先快照读再当前读</strong>。</p><ul><li>案例一</li></ul><ol><li>事务 A 执行普通的 <code>select</code> 语句查询 <code>id = 1</code> 的数据，此时表中不存在该数据，所以查不出来。</li><li>然后事务 B 插入 <code>id = 1</code> 的数据，并提交事务。</li><li>事务 A 再次使用普通的 <code>select</code> 语句查询 <code>id = 1</code> 的数据，还是查不出来，因为这是快照读的方式。</li><li>但是事务 A 使用 <code>select ... for update</code> 当前读去查，就能查到 <code>id = 1</code> 的数据。</li></ol><p>先快照读，再当前读就出现了幻读。</p><ul><li>案例二</li></ul><p>假设系统中用户名是不允许重复的，那我们可以给用户名添加唯一索引。</p><ol><li>事务 A 使用普通的 <code>select</code> 语句查询是否存在用户名为 <code>zhangsan</code> 的用户，此时表中不存在该数据，所以查不出来。 </li><li>然后事务 B 插入了用户名为 <code>zhangsan</code> 的用户,并提交了事务。</li><li>此时事务 A 插入了 <code>username = zhangsan</code> 的数据发现插入不了，提示用户名为 <code>zhangsan</code> 的已存在。</li><li>事务 A 再次使用普通 <code>select</code> 语句查询用户名为 <code>zhangsan</code> 的用户，该方式是快照读，所以还是查不到数据。</li><li>此时就出现了问题：明明查询到没有用户名为 <code>zhangsan</code> 的数据，但是一插入就提示已存在，这就是幻读现象。</li><li>但是更骚的来了，事务 A 查不到 <code>username = zhangsan</code> ，但是直接使用 <code>update</code> 语句却能够修改用户名为 <code>zhangsan</code> 的数据。</li><li>就是这么诡异，你查不到无法插入，但是可以修改，修改完后再去查就能查到了。</li></ol><p>这也是一种先快照读，再当前读出现的幻读现象。</p><p>那该怎么解决这种现象下出现的幻读？</p><p>解决思路就是：在一个事务操作某张表的时候，不允许其他事务也操作这张表标即可。也就是说，要么给表加表锁，要么给表中的数据加行锁，使用 <code>select ... for update</code> 即可。</p><ul><li>加表锁</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务 1</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 执行成功, 加表锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务2</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 阻塞</span></span><br><span class="line"><span class="keyword">insert into</span> <span class="keyword">user</span> ...;  <span class="comment">--  阻塞</span></span><br></pre></td></tr></table></figure><ul><li>加行锁</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务 1</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> 索引列 <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 执行成功, 加行锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务2</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> 索引列 <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 阻塞</span></span><br><span class="line"><span class="keyword">insert into</span> <span class="keyword">user</span> ...; <span class="comment">-- 阻塞</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> MVCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保证缓存与数据库的一致性</title>
      <link href="/2025/08/24/Redis/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2025/08/24/Redis/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>想要解决缓存与数据库的一致性问题，需要先了解常见的缓存更新策略。</p><h1 id="常见的缓存更新策略"><a href="#常见的缓存更新策略" class="headerlink" title="常见的缓存更新策略"></a>常见的缓存更新策略</h1><h2 id="旁路缓存"><a href="#旁路缓存" class="headerlink" title="旁路缓存"></a>旁路缓存</h2><p>旁路缓存就是 Cache Aside，也是<strong>我们平时业务中经常使用的一种方式</strong>。</p><p>旁路缓存读取数据的基本流程是：先从 Redis 缓存中读取数据，数据存在则直接返回，数据不存在则需要数据库中去读取，然后再写入缓存。</p><p>旁路缓存写入就比较麻烦了：先写入缓存还是先写数据库、写入缓存还是删除缓存、怎么保证缓存与数据库的一致性 ……，这个有点麻烦，我们后续再说。</p><p>总结起来，旁路缓存这种方式的特点就是业务代码既要操作数据库又要操作缓存，以数据库的数据为主，缓存只是暂时存储数据而已。这就是我们经常使用的旁路缓存 Cache Aside。</p><h2 id="读穿写穿"><a href="#读穿写穿" class="headerlink" title="读穿写穿"></a>读穿写穿</h2><p>读穿 Read Through、写穿 Write Through，这是第二种常见的缓存更新策略。它的设计思想是：<strong>不直接操作数据库，只操作缓存，让缓存自身去操作数据库</strong>。 </p><p>读穿的意思是，每次都从缓存中进行读取。如果缓存中存在，则直接返回；如果缓存中不存在数据，则让 <strong>缓存自身</strong> 去数据库中进行查询，然后写入到缓存当中，返回数据。</p><p>写穿的意思是，每次写入数据，直接写入到缓存当中，后续 <strong>缓存自身</strong> 再写入数据到数据库当中。</p><p>总结起来，读穿写穿就是让我们直接操作缓存，只与缓存进行交互，读写数据库的操作交由缓存中间件自身完成。</p><h2 id="写回"><a href="#写回" class="headerlink" title="写回"></a>写回</h2><p>第三种缓存更新策略是写回 Write Back。写回与读穿写穿的思路是一致的，都是直接操作缓存，读写数据库的操作交由缓存中间件自身完成，但是区别是：<strong>写回是异步的写入数据到数据库</strong>。</p><p>也就是说，写回操作只写入数据到缓存，然后让后台线程异步的把缓存的更新写入数据库。这种非常适合写多读少的场景，但是因为是异步地写数据库，所以如果突然宕机, 会有数据丢失的可能。</p><h2 id="思想的应用"><a href="#思想的应用" class="headerlink" title="思想的应用"></a>思想的应用</h2><p>无论是读穿写穿，还是写回，目前做业务的缓存，像 Redis 或者 Memcached， 又或者大厂自研的缓存中间件都没提供这种缓存自身和数据库交互的功能，但是这种思想其实大量的应用到了操作系统和一些中间件的底层设计。</p><p>比如 MySQL 的 Buffer Pool。Buffer Pool 就是 MySQL 在内存中的 一个缓冲池。MySQL 插入数据都是先写入 Buffer Pool，然后在某个时间异步的刷到磁盘当中。然后 MySQL 通过 redolog 来避免数据丢失。</p><p>再比如操作系统的内核缓冲区 Page Cache，其本质也是一个缓存。也是先把数据写入到 Page Cache，然后操作系统在某个时间把数据刷入到磁盘当中。</p><p>其实一些典型的应用场景也使用了这种思想。比如 IDEA 编辑器、画图的软件或者写简历的在线网站，你不去点保存，它也会在某个时间自动地保存数据到磁盘或云端当中，这就是写回思想的一种应用。</p><h1 id="怎么保存缓存和数据库的数据一致性？"><a href="#怎么保存缓存和数据库的数据一致性？" class="headerlink" title="怎么保存缓存和数据库的数据一致性？"></a>怎么保存缓存和数据库的数据一致性？</h1><p>现在我们回头再来看最常用的旁路缓存的写入策略，看看这种更新策略是如何保存缓存和数据库的数据一致性。</p><h2 id="先更新缓存，再更新数据库"><a href="#先更新缓存，再更新数据库" class="headerlink" title="先更新缓存，再更新数据库"></a>先更新缓存，再更新数据库</h2><p>假设有如下的场景：</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250824204455930.png" alt="image-20250824204455742" style="zoom:60%;" /><p>这样就会出现缓存和数据库的不一致性。</p><h2 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h2><p>那我们反过来换一个思路：先更新数据库，再更新缓存。假设存在如下的场景：</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250824204903839.png" alt="image-20250824204903751" style="zoom:60%;" /><p>此时又出现了缓存和数据库的不一致性。</p><p>一起来看前两种方案，出现缓存和数据库的不一致性的原因主要是：缓存的更新与数据库的更新不是一个原子性的操作，在并发环境下就可能会出现不一致的问题。</p><p>那是不是只要保证缓存的更新与数据库的更新是一个原子性操作就能保证缓存和数据库的一致性？</p><p>此时我们会想到：<strong>分布式锁</strong> 。只要保证拿到锁的线程才能更新缓存，更新数据库，这不就保证原子性操作了吗，就能保证缓存和数据库的一致性了吗？</p><p>然而事实真是如此吗？</p><p>首先我们来分析，如果加了分布式锁，就不能并发写了，写操作一旦过多，还会导致性能问题。其次分布式锁本身也存在一些难以解决的问题，因此 <strong>使用分布式锁的方式不能够保证缓存和数据库的一致性</strong>。</p><p><strong>那选择使用分布式读写锁，利用其读读不互斥，读写互斥的特性？</strong></p><p>其实这种方案还不如第一种分布式锁的方案。首先读写锁是读写互斥的，读的时候不允许写；写的时候不允许读，这样就会导致如下的问题：</p><ul><li><p>在高并发场景下，大量的请求进来都在读取这个 key，此时你完全不能进行写操作；</p></li><li><p>如果此时你正在执行一个比较耗时的写操作，突然涌入大量的读取操作，那么这些大量的请求就只能阻塞等待写操作完成后在执行</p></li></ul><p>再退一步来说，我们为什么选择使用缓存？首先想到的就是 <strong>Redis 是基于内存操作，读写速率非常快！</strong> 但现在我们为了数据的一致性而选择了加锁这种比较重的资源，反而影响了 Redis 的读写性能，是不是本末倒置了，忘记了我们使用缓存的初衷？</p><p>综合来说，无论是先更新缓存还是先更新数据库，这两种方案是都不能保证缓存和数据库的一致性的。</p><h2 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h2><p>既然更新缓存行不通，那我们就再换个思路：删除缓存。这里选择删除缓存是因为以下两点原因：</p><ul><li>删除缓存操作相比于更新缓存代价更低，操作更便捷</li><li>如果更新了缓存没有请求去访问，然后数据库又进行了更新，那就意味着还需要重新更新缓存，那之前更新的缓存不就是无效的，没有意义的？</li></ul><p>所以对于缓存来说，最好的方案就是：需要查询的时候再去更新；更新数据库的时候直接删除缓存即可。</p><p>现在确定了策略就是先删除缓存，再更新数据库，此时还会不会出现缓存和数据库的不一致问题呢？</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250824211538686.png" alt="image-20250824211538503" style="zoom:60%;" /><p>可以看到，此时又又又出现了缓存和数据库的不一致性。</p><h2 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h2><p>既然有其他的请求会更新缓存，导致数据的不一致，那么可不可以把最后一次更新缓存的数据给删除了，这样不就能保证数据的一致性了吗？</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250824212102543.png" alt="image-20250824212102433" style="zoom:60%;" /><p>具体的操作就是：先删除缓存，再更新数据库，然后让线程等待一会再去执行删除最后更新的缓存。这里线程等待的原因就是留出时间给其他的线程进行读取数据库数据并写入缓存的操作，然后再把写入缓存的数据一删，这样就保证了缓存与数据库的一致性，这多是一件美事！🤪🤪🤪</p><p>然而事实就是这样吗？这里还存在一个不确定性的因素：延迟双删，那么线程应该等待多久呢，到底需要多长时间其他线程能完成进行读取数据库数据并写入缓存的操作呢？</p><p>这不仅需要考虑当时的网络情况，还跟服务器与数据库的负载相关，这个时间是不确定的，没有一个准确的值。因此延迟双删这个方案也是不可行的。</p><h2 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h2><p>那我思路再变，先更新数据库，再删除缓存。</p><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250824213234931.png" alt="image-20250824213234830" style="zoom:60%;" /><p>但是此时又又又又又出现了缓存与数据库数据的不一致问题！！！</p><p>不过这种方案出现缓存与数据库数据的不一致性是概率很低的。需要同时满足以下两点原因才有可能出现不一致性：</p><ul><li>Key 正好过期且数据库也需要更新数据</li><li><strong>请求 1 写缓存的速度</strong> 要小于 <strong>请求 2 更新数据库数据加删除缓存的概率</strong> ，这是概率极其低的</li></ul><p>由此来说：<strong>先更新数据库，再删除缓存，这种方案在绝大多数情况下是可行的</strong>。</p><h3 id="如果数据库更新成功，缓存删除失败了呢？"><a href="#如果数据库更新成功，缓存删除失败了呢？" class="headerlink" title="如果数据库更新成功，缓存删除失败了呢？"></a>如果数据库更新成功，缓存删除失败了呢？</h3><p>这种情况下就又又又出现了缓存与数据库数据的不一致问题，所以我们的解决思路应该是：<strong>必须要确保删除缓存的操作要成功执行</strong>。</p><p>为了保证成功执行，我们主要有两个方案：使用 MQ 或 监听 binlog 日志。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>把删除缓存的操作放入到 MQ 中去异步的执行，如果删除失败了，就可以利用 MQ 的重试机制进行重试，这样就能够有效保证删除缓存操作的执行。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>数据库更新数据的时候会产生一个 binlog 日志，我们也可以通过监听 MySQL 的 binlog 日志，如果日志中出现了数据，就代表 MySQL 进行了更新操作。我们再执行相应的删除缓存操作，删除失败再进行重试即可。</p><p>所以综合看下来，最理想的方案就是：<strong>先更新数据库，然后通过 MQ 或 监听 binlog 的方式异步删除缓存，如果删除缓存失败就进行重试。</strong></p><h1 id="主从模式下的不一致性问题"><a href="#主从模式下的不一致性问题" class="headerlink" title="主从模式下的不一致性问题"></a>主从模式下的不一致性问题</h1><p>实际上企业或公司的数据库都是主从模式读写分离的，主库负责写操作，从库负责读取，主库更新数据之后再同步给从库。</p><p>此时就会出现一个问题：主库执行数据更新操作并删除缓存之后，还没来得及同步给从库，此时又来了请求读取该数据，从库负责读，那么势必会读取从库的旧数据，然后写入缓存，这就又造成了缓存和数据库数据的不一致性，当然这种概率也是非常非常非常低的。</p><p>而想要解决这个问题，那就需要在主库更新数据后的一段时间内让后续的请求强制读取主库。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>此时到这里我们就应该明白：<strong>想要完全的保证缓存与数据库数据的一致性，那是不可能的</strong>。</p><p>我们最常用的方式就是：<strong>先更新数据库，然后通过 MQ 或 监听 binlog 的方式异步删除缓存，如果删除缓存失败就进行重试。</strong> 这也只是尽可能地保证缓存和数据库的在绝大多数场景下的一致性，同时我们也需要设置好数据的过期时间，即使某些极端场景下出现了不一致性问题，那也能够及时保证脏数据的过期失效。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁介绍及基本原理</title>
      <link href="/2025/08/22/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2025/08/22/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="锁与分布式锁"><a href="#锁与分布式锁" class="headerlink" title="锁与分布式锁"></a>锁与分布式锁</h1><p>在多线程环境中，如果多个线程同时访问共享资源 (例如商品库存、外卖订单)，会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。</p><p>举个例子，假设现在有 100 个用户参与某个限时秒杀活动，每位用户限购 1 件商品，且商品的数量只有 3 个。如果不对共享资源进行互斥访问，就可能出现以下情况：</p><ul><li>线程 1、2、3 等多个线程同时进入抢购方法，每一个线程对应一个用户。</li><li>线程 1 查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。</li><li>线程 2 也执行查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。</li><li>线程 1 继续执行，将库存数量减少 1 个，然后返回成功。</li><li>线程 2 继续执行，将库存数量减少 1 个，然后返回成功。</li><li>此时就发生了超卖问题，导致商品被多卖了一份。</li></ul><h2 id="锁的出现"><a href="#锁的出现" class="headerlink" title="锁的出现"></a>锁的出现</h2><p>为了保证共享资源被安全地访问，我们需要使用互斥操作对共享资源进行保护，<strong>即同一时刻只允许一个线程访问共享资源</strong>，其他线程需要等待当前线程释放后才能访问。这样可以避免数据竞争和脏数据问题，保证程序的正确性和稳定性。</p><p>在计算机领域，锁可以理解为针对某项资源使用权限的管理，它通常用来 <strong>控制共享资源</strong>，比如一个进程内有多个线程竞争一个数据的使用权限，解决方式之一就是加锁，更确切的说则是 “悲观锁”。</p><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题 (比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会被阻塞，直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><p>对于单体应用来说，在 Java 中，我们通常会使用 <code>ReentrantLock</code> 类、<code>synchronized</code> 关键字这类 JDK 本身就拥有的方式来控制一个 JVM 进程内的多个线程对共享资源的访问。<br><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250822182730857.png" alt="image-20250822182442644" /><br>从图中可以看出，这些线程访问共享资源是互斥的，<strong>同一时刻只有一个线程可以获取到本地锁访问共享资源</strong>。</p><h2 id="分布式锁的出现"><a href="#分布式锁的出现" class="headerlink" title="分布式锁的出现"></a>分布式锁的出现</h2><p>分布式系统下，不同的服务&#x2F;客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，<strong>分布式锁</strong> 就诞生了。</p><p>举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于 <strong>不同的 JVM 进程</strong> 中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。<br><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250822183716898.png" alt="image-20250822183716824" /><br>从图中可以看出，这些独立的进程中的线程访问共享资源是互斥的，<strong>同一时刻只有一个线程可以获取到分布式锁访问共享资源</strong>。</p><h1 id="分布式锁设计注意事项"><a href="#分布式锁设计注意事项" class="headerlink" title="分布式锁设计注意事项"></a>分布式锁设计注意事项</h1><h2 id="设计分布式锁需要具备哪些条件？"><a href="#设计分布式锁需要具备哪些条件？" class="headerlink" title="设计分布式锁需要具备哪些条件？"></a>设计分布式锁需要具备哪些条件？</h2><p>1、<strong>互斥</strong>：同一时刻保证只有一个线程能够获得锁，去访问共享资源。</p><p>2、<strong>高可用</strong>：要保证即使出现异常的情况也要对锁进行释放，确保不会影响其他线程对共享资源的访问。</p><p>3、<strong>可重入</strong>：一个节点获取了锁之后，还可以再次获取到锁，并且不止一次。</p><p>4、<strong>高性能</strong>：获取和释放锁的操作应该快速完成，并且尽量不要对整个系统的性能造成太大的影响。</p><p>5、<strong>对称性</strong>：确保加锁和解锁的是同一个线程，避免出现锁的 “误释放”。</p><h2 id="分布式锁有哪些实现方案？"><a href="#分布式锁有哪些实现方案？" class="headerlink" title="分布式锁有哪些实现方案？"></a>分布式锁有哪些实现方案？</h2><p>主流的分布式锁实现方案主要有 3 种：</p><ul><li>基于关系型数据库 MySQL 实现分布式锁</li><li>基于分布式存储系统 Redis 或 Etcd 实现分布式锁</li><li>基于分布式协调服务 ZooKeeper 实现分布式锁</li></ul><p>鉴于种种原因，实际在生产过程中使用 Redis 或 ZooKeeper 实现分布式锁居多。</p><h1 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h1><h2 id="基于-Redis-循序渐进实现分布式锁"><a href="#基于-Redis-循序渐进实现分布式锁" class="headerlink" title="基于 Redis 循序渐进实现分布式锁"></a>基于 Redis 循序渐进实现分布式锁</h2><h3 id="最简单的分布式锁"><a href="#最简单的分布式锁" class="headerlink" title="最简单的分布式锁"></a>最简单的分布式锁</h3><p>要实现一个分布式锁，得满足锁的基本特性：即一个线程拿到锁，另一个线程就拿不到，就不能往下走，这就是锁的互斥性。</p><p>在 Redis 当中，提供了一个 <code>SETNX</code> 的命令来帮助我们实现一个简单的分布式锁。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure><p>Redis 官方对于该命令的解释是：<code>Set the string value of a key only when the key doesn&#39;t exist</code> 只有当 key 不存在的时候，才会设置 key 的值 (加锁)。这样就可以帮助我们天然的实现分布式场景下的互斥性。</p><p>但是为了保证对称性，在解锁的时候我们则需要先判断这个锁是否是当前线程加的锁，从而避免释放掉别人的锁。此时就包括两个步骤：判断、释放锁。但是为了避免多线程环境下的并发安全问题，我们则需要使用 Lua 脚本来保证这两条命令的原子性。</p><p>释放锁的 Lua 脚本示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁时, 先比较锁对应的 value 值是否相等, 避免锁的误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>至于为什么不把 <code>SETNX</code> 命令放到 Lua 脚本当中，这是因为 Redis 执行操作命令是单线程执行的，天然就是原子性操作。</p><p>这是实现分布式锁的最简易版本，会存在大量的问题。比如：<strong>如果一个线程拿到锁之后就挂了，此时就无法释放锁了，该怎么办？</strong></p><h3 id="带有过期时间的分布式锁"><a href="#带有过期时间的分布式锁" class="headerlink" title="带有过期时间的分布式锁"></a>带有过期时间的分布式锁</h3><p>为了解决上述出现的问题，我们就需要给这个锁设置一个过期时间。Redis 当中也存在了设置过期时间对应的 <code>SET</code> 命令。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]</span><br></pre></td></tr></table></figure><p>具体解释每一个命令如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> SET key value: 设置 key 与 value</span><br><span class="line"><span class="bullet">2.</span> []: 代表可选操作</span><br><span class="line"><span class="bullet">3.</span> NX|XX: 二选一属性</span><br><span class="line"><span class="bullet">   -</span> NX(Not Exists): 只有当 key 不存在的时候才会设置 key 的值, 相当于上面的 <span class="code">`SETNX`</span> 命令</span><br><span class="line"><span class="bullet">   -</span> XX(Exists): 只有当 key 存在的时候才会设置 key 的值, 不存在则忽略该操作</span><br><span class="line"><span class="bullet">4.</span> GET: 执行 <span class="code">`SET`</span> 操作的同时返回原来的旧值, 如果 key 不存在, 返回 nil</span><br><span class="line"><span class="bullet">   -</span> 示例: </span><br><span class="line"><span class="bullet">       1.</span> 执行: SET name &quot;Alice&quot;</span><br><span class="line"><span class="bullet">       2.</span> 返回: OK</span><br><span class="line"><span class="bullet">       3.</span> 执行: SET name &quot;Bob&quot; GET</span><br><span class="line"><span class="bullet">       4.</span> 返回: &quot;Alice&quot;</span><br><span class="line"><span class="bullet">5.</span> 过期时间参数, 只能选一个</span><br><span class="line"><span class="bullet">   -</span> EX seconds: 设置过期时间为 xx 秒(整数)</span><br><span class="line"><span class="bullet">   -</span> PX milliseconds: 设置过期时间为 xx 毫秒(整数)</span><br><span class="line"><span class="bullet">   -</span> EXAT unix-time-seconds: 设置过期的 Unix 时间戳(秒级), 到指定时间后过期</span><br><span class="line"><span class="bullet">   -</span> PXAT unix-time-milliseconds: 设置过期的 Unix 时间戳(毫秒级), 到指定时间后过期</span><br><span class="line"><span class="bullet">   -</span> KEEPTTL: 保留 key 原有的过期时间(如果 key 已存在且有过期时间, 则不改变其过期时间; 如果 key 不存在, 则设置为永久)</span><br></pre></td></tr></table></figure><p>针对于 <code>SET</code> 命令实现可过期的分布式锁，具体的命令示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数的顺序不会影响命令</span></span><br><span class="line">SET lockKey uniqueValue EX 3 NX 或 SET lockKey uniqueValue NX EX 3 <span class="comment"># 3s 后过期</span></span><br></pre></td></tr></table></figure><p>这种方式实现的分布式锁还是会存在问题：<strong>假设线程拿到锁后任务还没有执行完成，锁就已经过期了，这个时候该怎么办？</strong></p><h3 id="锁的优雅续期"><a href="#锁的优雅续期" class="headerlink" title="锁的优雅续期"></a>锁的优雅续期</h3><p>此时我们应该想：如果能够自动判断锁的过期时间，在业务还没执行完的时候进行锁的自动续期，这该多是一件美事！！！</p><p>针对于这种情况，Java 已经有了现成的解决方案：<strong>Redisson</strong>。Redisson 是一个基于 Redis 的 Java 高级客户端，底层基于 Netty 实现。Redisson 提供了如分布式锁、分布式限流、分布式集合等高级特性。</p><p>Redisson 中的分布式锁自带自动续期机制，使用起来非常简单。其提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。<br><img src="https://picgo-blog-1335849645.cos.ap-guangzhou.myqcloud.com/images/20250822195810641.png" alt="image-20250822195810515" /><br>关于 Watch Dog 看门狗机制，这里不做过多阐述，后续会单独写一篇文章进行详细说明。</p><p>通过续期方式实现的分布式锁还是会存在一定的问题：<strong>假设线程拿到锁在执行业务方法的时候挂了，这时候  Watch Dog 就会不断地给锁进行续期，该怎么解决？有些场景还需要使用到可重入的分布式锁，又该怎么解决？</strong></p><h3 id="可重入的分布式锁"><a href="#可重入的分布式锁" class="headerlink" title="可重入的分布式锁"></a>可重入的分布式锁</h3><p>针对于上述第一个问题，我们可以这样操作：</p><ul><li>把看门狗线程设置为守护线程，守护线程的生命周期依赖于其他线程，一旦拿到锁的线程在执行业务的时候挂了，那么看门狗作为守护线程也是会停止的。</li><li>我们也需要给看门狗设置一个时间 (默认30s 续期一次)，避免无限续期。</li></ul><p>下面来讨论可重入分布式锁的实现。</p><p>可重入锁指的是 <strong>在一个线程中可以多次获取同一把锁</strong>。比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程就需要多次来获取同一个锁，这就是可重入锁。</p><p>Java 中的 <code>synchronized</code> 和 <code>ReentrantLock</code> 都属于可重入锁。</p><p>那我们该怎么实现一个可重入锁呢？在解答这个问题之前，需要先看看 <code>synchronized</code> 和 <code>ReentrantLock</code> 是怎么实现可重入的。</p><p>synchronized 给每个对象都关联了一个锁监视器，监视器中有个字段是锁计数器。锁重入一次，计数器加一次，锁释放一次，计数器减一次，当计数器为 0 的时候，就是锁释放完毕的时候。</p><p>ReentrantLock 基于 AQS 进行实现。AQS 中存在一个 state 字段，state 字段就充当了锁计数器，锁重入一次，state 加一次，锁释放一次，state 减一次，当 state 为 0 的时候，就是锁释放完毕的时候。</p><p>那么对于可重入的分布式锁，实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 <strong>Redisson</strong> ，其内置了多种类型的锁。比如可重入锁 (Reentrant Lock)、自旋锁 (Spin Lock)、公平锁 (Fair Lock)、多重锁 (MultiLock)、 红锁 (RedLock)、 读写锁 (ReadWriteLock)。</p><p>而如果让我们自行实现可重入的分布式锁，则也需要根据锁计数器来实现，主要的实现方案有以下两种。</p><h4 id="第一种方案"><a href="#第一种方案" class="headerlink" title="第一种方案"></a>第一种方案</h4><p>使用 Redis 的哈希结构，以要锁的东西为 key，以当前的线程 Id 为 field，以重入次数为 value，这个 value 充当的角色就是锁计数器。</p><p>当然，这种方案也是 Redisson 可重入锁的实现方案，使用的是 <code>HSETNX</code> 命令。</p><p>但是由于集群环境下可能会出现线程 Id 重复的现象，我们最好是使用当前的线程 Id 再拼接一个 UUID 来保证唯一性。</p><h4 id="第二种方案"><a href="#第二种方案" class="headerlink" title="第二种方案"></a>第二种方案</h4><p>不使用 Redisson 提供好的可重入分布式锁，还是使用 Redis 中的 String 结构的 <code>SET NX EX</code> 命令来实现分布式锁，但是在服务内部维护一个 <code>ConcurrentHashMap</code> ，以 map 的 value 作为锁计数器，来实现锁的可重入性。</p><h3 id="Redisson-中的发布订阅"><a href="#Redisson-中的发布订阅" class="headerlink" title="Redisson 中的发布订阅"></a>Redisson 中的发布订阅</h3><p><strong>如果一个线程抢到锁去执行业务去了，那么其他没抢到锁的线程就直接返回失败吗？</strong></p><p>当然不是。没抢到锁的线程不会直接返回失败信息，可以进行重试机制。分布式锁也可以通过不断自旋来尝试重新抢锁，但是 Redisson 底层不是这么实现的。</p><p>Redisson 基于 Redis 的发布订阅机制，让没有抢到锁的线程进行订阅，然后阻塞等待。</p><p>抢到锁的线程执行完任务后会发布一条消息来通知订阅的所有线程，唤醒它们进行重新抢锁。</p><p>没抢到锁的线程继续订阅，抢到锁的线程继续执行业务，执行完业务后继续发布消息，如此循环往复。不过需要注意的是要添加一个超时时间来进行控制，避免抢不到锁的线程无限等待下去。</p><h3 id="Redis-集群环境下的锁丢失问题"><a href="#Redis-集群环境下的锁丢失问题" class="headerlink" title="Redis 集群环境下的锁丢失问题"></a>Redis 集群环境下的锁丢失问题</h3><p>如果 Redis 是一主多从的集群模式，当执行分布式锁的 Redis 命令写入到主节点后，主节点正在或是即将同步数据给从节点的某一刻，Redis 的主节点突然宕机了，那么就会触发 Redis 的重新选主操作，选择某一个从节点转化为主节点。</p><p>但是新的主节点是没有分布式锁的数据的，那么其他线程还是能够加锁成功的，由于开始的主节点宕机没有及时同步数据到从节点，这就造成了第一次加的锁造成了丢失，这又该如何应对？</p><h4 id="Redisson-的联锁-MultiLock"><a href="#Redisson-的联锁-MultiLock" class="headerlink" title="Redisson 的联锁 (MultiLock)"></a>Redisson 的联锁 (MultiLock)</h4><p>针对于以上锁丢失问题，Redisson 提供了 <strong>联锁</strong> 机制来解决。联锁要求 Redis 部署多主多从的集群环境。</p><p>每次加锁都必须给所有主节点都加上锁才算加锁成功。</p><p>这样即便某个主节点还没来得及同步数据就宕机，那么其他几个主节点也是有锁的数据的，新线程再想加锁, 由于无法给所有主节点都加锁，还是会加锁失败的。这样就解决了一主多从模式下锁丢失的问题。</p><p><strong>但是真的完美了吗？</strong></p><p><strong>在给所有主节点加锁的过程中，如果某个主节点网络延迟很大，加锁很慢，或者说某个主节点宕机了，一直加锁失败，由于联锁的机制，那就会导致整体加锁失败。</strong></p><p><strong>此时我们又该如何应对？</strong></p><h4 id="Redisson-的红锁-RedLock"><a href="#Redisson-的红锁-RedLock" class="headerlink" title="Redisson 的红锁 (RedLock)"></a>Redisson 的红锁 (RedLock)</h4><p>此时就需要请出 Redisson 的又一个锁机制了：<strong>RedLock 红锁</strong>。RedLock 也要求 Redis 部署多主多从的集群环境，但是加锁的时候不需要全部的主节点都加锁成功，而是只需要 <strong>半数以上的主节点加锁成功即可</strong> 。</p><p>当某个线程加锁半数以上节点都成功了，那其他线程就不可能再做到半数以上加锁成功，这就满足了互斥性。</p><p>同时 RedLock 对加锁时间也有很严格的要求，如果某个节点一定时间内加不上锁就不等了，反正只要半数以上成功就行，放弃一两个比较慢的主节点是无所谓的。</p><p><strong>但是但是但是，到这里就万无一失了吗？</strong></p><p>显然并不是，RedLock 还存在一些其他的问题：</p><ul><li>RedLock 对时间要求很严格，但是不同节点的系统时钟也可能不一致，从而导致问题。</li><li>Java 的 GC 过程中是会暂停线程的，从而导致看门狗线程无法对锁进行续期，也可能导致锁的超时过期。</li><li>RedLock 自身也存在一定的问题，且需要搭建复杂的多主多从集群模式，维护起来非常困难，还要保证多个节点之间的数据一致性，因此 RedLock 的使用场景并不广泛。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上所述，实现分布式锁的最佳实践有两种方式：</p><ul><li>基于 Redis 的 <code>SET NX EX</code> 实现简单的不可重入的分布式锁。</li><li>直接使用 Redisson 提供好的分布式锁机制。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
            <tag> Redisson </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
